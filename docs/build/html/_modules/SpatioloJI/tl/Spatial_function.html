

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SpatioloJI.tl.Spatial_function &mdash; SpatioloJI 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=2d01f2b6" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=2d01f2b6" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SpatioloJI
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#dependencies">Dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_concepts.html">SpatioloJI Object Structure</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#core-components">Core Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#component-details">Component Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#adata-anndata-object">adata (AnnData Object)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#cell-meta-dataframe">cell_meta (DataFrame)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#polygons-dataframe">polygons (DataFrame)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#fov-positions-dataframe">fov_positions (DataFrame)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#images-dictionary">images (Dictionary)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#integration-and-relationships">Integration and Relationships</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#creating-a-spatioloji-object">Creating a SpatioloJI Object</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#from-individual-components">From Individual Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#from-files">From Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#from-pickle">From Pickle</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#key-methods">Key Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#data-access">Data Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../basic_concepts.html#custom-data">Custom Data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../basic_concepts.html#summary">Summary</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">CosMx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#basic-tutorials">Basic Tutorials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/QC_filtering.html">Quality Control and Filtering for Raw Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/QC_filtering.html#Prepare-original-data">Prepare original data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/QC_filtering.html#Instantiation-of-Spatioloji_qc-object">Instantiation of Spatioloji_qc object</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/Scanpy_SpatioloJI.html">Integrate Scanpy into Spatiology Workflow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/Scanpy_SpatioloJI.html#Run-basic-workflow-of-Scanpy">Run basic workflow of Scanpy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/Scanpy_SpatioloJI.html#Imputation">Imputation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/Scanpy_SpatioloJI.html#Instantiate-SpatioloJI-object">Instantiate SpatioloJI object</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/Basic_Visualization.html">Basic Visualization for Polygons or Dots in Spatial Images/ Stitiched Images</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/Basic_Visualization.html#Plot">Plot</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#advanced-tutorials">Advanced Tutorials</a><ul class="simple">
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a><ul class="simple">
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/data.html">Data (data)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/data.html#spatial-object">Spatial Object</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/data.html#SpatioloJI.data.Spatial_Object.Spatioloji"><code class="docutils literal notranslate"><span class="pre">Spatioloji</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/data.html#SpatioloJI.data.Spatial_Object.Spatioloji_qc"><code class="docutils literal notranslate"><span class="pre">Spatioloji_qc</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/pl.html">Plotting (pl)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/pl.html#plot-spatial-image">Plot Spatial Image</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.stitch_fov_images"><code class="docutils literal notranslate"><span class="pre">stitch_fov_images()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_global_polygon_by_features"><code class="docutils literal notranslate"><span class="pre">plot_global_polygon_by_features()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_global_polygon_by_categorical"><code class="docutils literal notranslate"><span class="pre">plot_global_polygon_by_categorical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_global_dot_by_features"><code class="docutils literal notranslate"><span class="pre">plot_global_dot_by_features()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_global_dot_by_categorical"><code class="docutils literal notranslate"><span class="pre">plot_global_dot_by_categorical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_local_polygon_by_categorical"><code class="docutils literal notranslate"><span class="pre">plot_local_polygon_by_categorical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_local_polygon_by_features"><code class="docutils literal notranslate"><span class="pre">plot_local_polygon_by_features()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_local_dots_by_categorical"><code class="docutils literal notranslate"><span class="pre">plot_local_dots_by_categorical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pl.html#SpatioloJI.pl.Plot_Spatial_Image.plot_local_dots_by_features"><code class="docutils literal notranslate"><span class="pre">plot_local_dots_by_features()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/tl.html">Tools (tl)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/tl.html#spatial-functions">Spatial Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.perform_neighbor_analysis"><code class="docutils literal notranslate"><span class="pre">perform_neighbor_analysis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_nearest_neighbor_distances"><code class="docutils literal notranslate"><span class="pre">calculate_nearest_neighbor_distances()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_cell_density"><code class="docutils literal notranslate"><span class="pre">calculate_cell_density()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_ripleys_k"><code class="docutils literal notranslate"><span class="pre">calculate_ripleys_k()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_cross_k_function"><code class="docutils literal notranslate"><span class="pre">calculate_cross_k_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_j_function"><code class="docutils literal notranslate"><span class="pre">calculate_j_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_g_function"><code class="docutils literal notranslate"><span class="pre">calculate_g_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_pair_correlation_function"><code class="docutils literal notranslate"><span class="pre">calculate_pair_correlation_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_cell_type_correlation"><code class="docutils literal notranslate"><span class="pre">calculate_cell_type_correlation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_colocation_quotient"><code class="docutils literal notranslate"><span class="pre">calculate_colocation_quotient()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_proximity_analysis"><code class="docutils literal notranslate"><span class="pre">calculate_proximity_analysis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_morisita_index"><code class="docutils literal notranslate"><span class="pre">calculate_morisita_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_quadrat_variance"><code class="docutils literal notranslate"><span class="pre">calculate_quadrat_variance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_entropy"><code class="docutils literal notranslate"><span class="pre">calculate_spatial_entropy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_hotspot_analysis"><code class="docutils literal notranslate"><span class="pre">calculate_hotspot_analysis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_autocorrelation"><code class="docutils literal notranslate"><span class="pre">calculate_spatial_autocorrelation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_kernel_density"><code class="docutils literal notranslate"><span class="pre">calculate_kernel_density()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_heterogeneity"><code class="docutils literal notranslate"><span class="pre">calculate_spatial_heterogeneity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_mark_correlation"><code class="docutils literal notranslate"><span class="pre">calculate_mark_correlation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_context"><code class="docutils literal notranslate"><span class="pre">calculate_spatial_context()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_network_statistics"><code class="docutils literal notranslate"><span class="pre">calculate_network_statistics()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_gene_spatial_autocorrelation"><code class="docutils literal notranslate"><span class="pre">calculate_gene_spatial_autocorrelation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/utils.html">Utilities (utils)</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing to SpatioloJI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#code-of-conduct">Code of Conduct</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#ways-to-contribute">Ways to Contribute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#setting-up-your-development-environment">Setting Up Your Development Environment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#development-workflow">Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#making-changes">Making Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#code-style">Code Style</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#submitting-changes">Submitting Changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#documentation">Documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#writing-docstrings">Writing Docstrings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#tutorials-and-examples">Tutorials and Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#testing">Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#writing-tests">Writing Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing/index.html#running-tests">Running Tests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#release-process">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing/index.html#getting-help">Getting Help</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog/index.html">changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog/index.html#version-0-2-0-2025-05-20">Version 0.2.0 (2025-05-20)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog/index.html#added">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog/index.html#fixed">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog/index.html#changed">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../changelog/index.html#deprecated">Deprecated</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../ecosystem/index.html">Ji Universe Ecosystem</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ecosystem/index.html#core-packages">Core Packages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ecosystem/index.html#spatioloji-core-foundation">SpatioloJI: Core Foundation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ecosystem/index.html#dimensionji-multidimensional-analysis">DimensionJI: Multidimensional Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ecosystem/index.html#communicoji-cell-cell-communication">CommunicoJI: Cell-Cell Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ecosystem/index.html#fusionji-image-transcriptome-integration">FusionJI: Image-Transcriptome Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ecosystem/index.html#encycloji-method-repository">EncycloJI: Method Repository</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ecosystem/index.html#resources">Resources</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpatioloJI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">SpatioloJI.tl.Spatial_function</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for SpatioloJI.tl.Spatial_function</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polygon</span> <span class="k">as</span> <span class="n">sPolygon</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Voronoi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>


<span class="c1"># Neighbor Analysis</span>
<div class="viewcode-block" id="perform_neighbor_analysis">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.perform_neighbor_analysis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">perform_neighbor_analysis</span><span class="p">(</span>
    <span class="n">polygon_file</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">cell_metadata</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">cell_type_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">save_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span>
    <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;neighbor_analysis&quot;</span><span class="p">,</span>
    <span class="n">include_plots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">figsize</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
    <span class="n">dpi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
    <span class="n">return_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform comprehensive neighbor distance analysis for cell polygons.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polygon_file : pd.DataFrame</span>
<span class="sd">        DataFrame with cell polygon vertices. Must include &#39;cell&#39;, &#39;x_local_px&#39;, &#39;y_local_px&#39; columns.</span>
<span class="sd">    cell_metadata : pd.DataFrame</span>
<span class="sd">        DataFrame with cell metadata. Must include &#39;cell&#39; and cell_type_column.</span>
<span class="sd">    cell_type_column : str</span>
<span class="sd">        Column in cell_metadata that defines cell types for analysis.</span>
<span class="sd">    distance_threshold : float, optional</span>
<span class="sd">        Maximum distance between polygons to be considered neighbors, by default 0.0</span>
<span class="sd">        (0.0 means polygons must be touching, positive values include nearby non-touching cells)</span>
<span class="sd">    save_dir : str, optional</span>
<span class="sd">        Directory to save result files, by default &quot;./&quot;</span>
<span class="sd">    filename_prefix : str, optional</span>
<span class="sd">        Prefix for output filenames, by default &quot;neighbor_analysis&quot;</span>
<span class="sd">    include_plots : bool, optional</span>
<span class="sd">        Whether to generate and save plots, by default True</span>
<span class="sd">    figsize : Tuple[int, int], optional</span>
<span class="sd">        Figure size for plots, by default (10, 8)</span>
<span class="sd">    dpi : int, optional</span>
<span class="sd">        DPI for saved figures, by default 300</span>
<span class="sd">    return_data : bool, optional</span>
<span class="sd">        Whether to return the analysis data, by default True</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Whether to display progress information, by default True</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict</span>
<span class="sd">        Dictionary containing analysis results if return_data is True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check required columns</span>
    <span class="n">poly_required_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;x_local_px&#39;</span><span class="p">,</span> <span class="s1">&#39;y_local_px&#39;</span><span class="p">]</span>
    <span class="n">poly_missing_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">poly_required_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">polygon_file</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">poly_missing_cols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing required columns in polygon_file: </span><span class="si">{</span><span class="n">poly_missing_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">meta_required_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="p">]</span>
    <span class="n">meta_missing_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">meta_required_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_metadata</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">meta_missing_cols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing required columns in cell_metadata: </span><span class="si">{</span><span class="n">meta_missing_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create output directory</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Convert polygons to Shapely objects</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converting cell polygons to Shapely objects...&quot;</span><span class="p">)</span>
    
    <span class="n">polygon_set</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">cell</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">polygon_file</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Create polygon from vertices</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">group</span><span class="p">[[</span><span class="s1">&#39;x_local_px&#39;</span><span class="p">,</span> <span class="s1">&#39;y_local_px&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            
            <span class="c1"># Skip cells with fewer than 3 vertices</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Cell </span><span class="si">{</span><span class="n">cell</span><span class="si">}</span><span class="s2"> has fewer than 3 vertices. Skipping.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
                
            <span class="c1"># Create Shapely polygon</span>
            <span class="n">polygon_tmp</span> <span class="o">=</span> <span class="n">sPolygon</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
            
            <span class="c1"># Skip invalid polygons</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">polygon_tmp</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Cell </span><span class="si">{</span><span class="n">cell</span><span class="si">}</span><span class="s2"> has an invalid polygon. Skipping.&quot;</span><span class="p">)</span>
                <span class="c1"># Could try to fix: polygon_tmp = polygon_tmp.buffer(0)</span>
                <span class="k">continue</span>
                
            <span class="n">polygon_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon_tmp</span><span class="p">)</span>
            <span class="n">cell_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing cell </span><span class="si">{</span><span class="n">cell</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create mapping from cell IDs to their positions in the list</span>
    <span class="n">cell_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)}</span>
    
    <span class="c1"># Get cell types</span>
    <span class="n">cell_meta_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_metadata</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">],</span> <span class="n">cell_metadata</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]))</span>
    
    <span class="c1"># Get cell types for each polygon</span>
    <span class="n">cell_types</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_meta_dict</span><span class="p">:</span>
            <span class="n">cell_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_meta_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2"> not found in metadata. Assigning &#39;Unknown&#39;.&quot;</span><span class="p">)</span>
            <span class="n">cell_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get unique cell types</span>
    <span class="n">unique_cell_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cell_types</span><span class="p">))</span>
    
    <span class="c1"># Find neighboring cells</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finding neighboring cells...&quot;</span><span class="p">)</span>
    
    <span class="n">neighbor_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neighbor_distances</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Use tqdm for progress tracking</span>
    <span class="n">total_comparisons</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon_set</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygon_set</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">total_comparisons</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygon_set</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon_set</span><span class="p">)):</span>
            <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">poly1</span> <span class="o">=</span> <span class="n">polygon_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">poly2</span> <span class="o">=</span> <span class="n">polygon_set</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            
            <span class="c1"># Check if polygons are neighbors</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">poly2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">:</span>
                <span class="n">neighbor_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cell_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">neighbor_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
    
    <span class="n">progress_bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Create neighbor dataframe</span>
    <span class="n">neighbor_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;cell1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">neighbor_pairs</span><span class="p">],</span>
        <span class="s1">&#39;cell2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">neighbor_pairs</span><span class="p">],</span>
        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">neighbor_distances</span>
    <span class="p">})</span>
    
    <span class="c1"># Add cell types</span>
    <span class="n">neighbor_df</span><span class="p">[</span><span class="s1">&#39;cell1_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_df</span><span class="p">[</span><span class="s1">&#39;cell1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_meta_dict</span><span class="p">)</span>
    <span class="n">neighbor_df</span><span class="p">[</span><span class="s1">&#39;cell2_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_df</span><span class="p">[</span><span class="s1">&#39;cell2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_meta_dict</span><span class="p">)</span>
    
    <span class="c1"># Save neighbor data</span>
    <span class="n">neighbor_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_pairs.csv&quot;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Create a network graph</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating cell interaction network...&quot;</span><span class="p">)</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    
    <span class="c1"># Add nodes with cell type attributes</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="n">cell_types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="c1"># Add edges with distance attributes</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">neighbor_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;cell1&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;cell2&#39;</span><span class="p">],</span> <span class="n">distance</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">])</span>
    
    <span class="c1"># Compute interaction counts between cell types</span>
    <span class="n">interaction_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">interaction_distances</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">neighbor_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">type_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;cell1_type&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;cell2_type&#39;</span><span class="p">]]))</span>
        <span class="n">interaction_counts</span><span class="p">[</span><span class="n">type_pair</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">interaction_distances</span><span class="p">[</span><span class="n">type_pair</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">])</span>
    
    <span class="c1"># Create interaction matrix</span>
    <span class="n">interaction_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">)))</span>
    <span class="n">avg_distance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">type1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">type2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">):</span>
            <span class="n">type_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">]))</span>
            <span class="n">interaction_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">interaction_counts</span><span class="p">[</span><span class="n">type_pair</span><span class="p">]</span>
            <span class="n">avg_distance_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">interaction_distances</span><span class="p">[</span><span class="n">type_pair</span><span class="p">])</span> <span class="k">if</span> <span class="n">interaction_distances</span><span class="p">[</span><span class="n">type_pair</span><span class="p">]</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># Make sure diagonal reflects interactions within same cell type</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">):</span>
        <span class="n">same_type_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>
        <span class="n">interaction_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interaction_counts</span><span class="p">[</span><span class="n">same_type_pair</span><span class="p">]</span>
        <span class="n">avg_distance_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">interaction_distances</span><span class="p">[</span><span class="n">same_type_pair</span><span class="p">])</span> <span class="k">if</span> <span class="n">interaction_distances</span><span class="p">[</span><span class="n">same_type_pair</span><span class="p">]</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># Store interaction data</span>
    <span class="n">interaction_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">interaction_matrix</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">unique_cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">unique_cell_types</span><span class="p">)</span>
    <span class="n">avg_distance_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">avg_distance_matrix</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">unique_cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">unique_cell_types</span><span class="p">)</span>
    
    <span class="c1"># Save interaction data</span>
    <span class="n">interaction_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_interaction_counts.csv&quot;</span><span class="p">))</span>
    <span class="n">avg_distance_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_avg_distances.csv&quot;</span><span class="p">))</span>
    
    <span class="c1"># Compute statistics for each cell</span>
    <span class="n">cell_stats</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">cell_id</span><span class="p">))</span>
        <span class="n">neighbor_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">]</span>
        <span class="n">type_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="n">neighbor_types</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">cell_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">unique_cell_types</span><span class="p">}</span>
        
        <span class="n">cell_stats</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;degree&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">),</span>
            <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;cell_type&#39;</span><span class="p">],</span>
            <span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s1">&#39;neighbor_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">_count&#39;</span><span class="p">:</span> <span class="n">count</span> <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">type_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="p">}</span>
    
    <span class="n">cell_stats_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">cell_stats</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
    <span class="n">cell_stats_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span>
    <span class="n">cell_stats_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Save cell statistics</span>
    <span class="n">cell_stats_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_cell_stats.csv&quot;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Calculate enrichment scores (observed/expected ratios)</span>
    <span class="n">cell_type_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="n">cell_types</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">cell_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">unique_cell_types</span><span class="p">}</span>
    <span class="n">total_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span>
    
    <span class="n">enrichment_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">type1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">type2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">):</span>
            <span class="c1"># Calculate expected interactions based on frequency</span>
            <span class="k">if</span> <span class="n">type1</span> <span class="o">==</span> <span class="n">type2</span><span class="p">:</span>
                <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell_type_counts</span><span class="p">[</span><span class="n">type1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cell_type_counts</span><span class="p">[</span><span class="n">type1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expected</span> <span class="o">=</span> <span class="n">cell_type_counts</span><span class="p">[</span><span class="n">type1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell_type_counts</span><span class="p">[</span><span class="n">type2</span><span class="p">]</span>
            
            <span class="c1"># Scale by total possible interactions</span>
            <span class="n">total_possible</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_cells</span> <span class="o">*</span> <span class="p">(</span><span class="n">total_cells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="n">expected</span> <span class="o">/</span> <span class="n">total_possible</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">interaction_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            
            <span class="c1"># Calculate enrichment (observed/expected)</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="n">interaction_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">enrichment</span> <span class="o">=</span> <span class="n">observed</span> <span class="o">/</span> <span class="n">expected</span> <span class="k">if</span> <span class="n">expected</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">enrichment_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">enrichment</span>
    
    <span class="c1"># Store enrichment data</span>
    <span class="n">enrichment_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">enrichment_matrix</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">unique_cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">unique_cell_types</span><span class="p">)</span>
    
    <span class="c1"># Save enrichment data</span>
    <span class="n">enrichment_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_enrichment.csv&quot;</span><span class="p">))</span>
    
    <span class="c1"># Generate plots if requested</span>
    <span class="k">if</span> <span class="n">include_plots</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating plots...&quot;</span><span class="p">)</span>
            
        <span class="c1"># Interaction heatmap</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">interaction_df</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;YlGnBu&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;.0f&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Cell Type Interaction Counts&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_interaction_heatmap.png&quot;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Average distance heatmap</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">avg_distance_df</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;YlGnBu&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;.2f&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Average Distance Between Cell Types&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_distance_heatmap.png&quot;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Enrichment heatmap</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">enrichment_df</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;coolwarm&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;.2f&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Cell Type Interaction Enrichment (Observed/Expected)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_enrichment_heatmap.png&quot;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Degree distribution by cell type</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">cell_stats_df</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">cell_stats_df</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Number of Neighbors by Cell Type&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_degree_boxplot.png&quot;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Network visualization (if fewer than 1000 cells for clarity)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
            
            <span class="c1"># Use spring layout for positioning</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            
            <span class="c1"># Create a color map for cell types</span>
            <span class="n">color_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">tab10</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ct</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">)}</span>
            <span class="n">node_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_map</span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
            
            <span class="c1"># Draw nodes and edges</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            
            <span class="c1"># Add a legend</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ct</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="n">color_map</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">ct</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Cell Interaction Network&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename_prefix</span><span class="si">}</span><span class="s2">_network.png&quot;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Prepare return data</span>
    <span class="k">if</span> <span class="n">return_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;neighbor_df&#39;</span><span class="p">:</span> <span class="n">neighbor_df</span><span class="p">,</span>
            <span class="s1">&#39;interaction_df&#39;</span><span class="p">:</span> <span class="n">interaction_df</span><span class="p">,</span>
            <span class="s1">&#39;avg_distance_df&#39;</span><span class="p">:</span> <span class="n">avg_distance_df</span><span class="p">,</span>
            <span class="s1">&#39;enrichment_df&#39;</span><span class="p">:</span> <span class="n">enrichment_df</span><span class="p">,</span>
            <span class="s1">&#39;cell_stats_df&#39;</span><span class="p">:</span> <span class="n">cell_stats_df</span><span class="p">,</span>
            <span class="s1">&#39;network&#39;</span><span class="p">:</span> <span class="n">G</span><span class="p">,</span>
            <span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">polygon_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">))}</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
<div class="viewcode-block" id="calculate_nearest_neighbor_distances">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_nearest_neighbor_distances">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_nearest_neighbor_distances</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the nearest neighbor distance for each cell.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        use_polygons: Whether to use polygon boundaries (True) or cell centers (False) for distance calculation</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with cell IDs and their nearest neighbor distances in pixels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_global_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_local_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns for centroid-based calculation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_center_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_center_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check if we have polygons data if using polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polygon data not available in the Spatioloji object&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a list to store results</span>
    <span class="n">nn_distances</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># If using polygons, create a dictionary of cell polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="c1"># Group polygons by cell</span>
        <span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">cell_poly_data</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_polygon_for_cell</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
            
            <span class="c1"># Skip if no polygon data found for this cell</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Create a polygon from the points</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">[</span><span class="n">x_poly_col</span><span class="p">],</span> <span class="n">cell_poly_data</span><span class="p">[</span><span class="n">y_poly_col</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for a polygon</span>
                    <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create polygon for cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># For each cell, calculate the distance to all other cells and find the minimum</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">cell_id</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="c1"># Skip if this cell doesn&#39;t have polygon data</span>
            <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">current_polygon</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
            
            <span class="c1"># Calculate distance to all other cell polygons</span>
            <span class="k">for</span> <span class="n">other_cell_id</span><span class="p">,</span> <span class="n">other_polygon</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">other_cell_id</span> <span class="o">!=</span> <span class="n">cell_id</span><span class="p">:</span>
                    <span class="c1"># Calculate distance between polygons</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">current_polygon</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">other_polygon</span><span class="p">)</span>
                    <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_distance</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">min_distance</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
                <span class="n">nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                    <span class="s1">&#39;nearest_neighbor_distance&#39;</span><span class="p">:</span> <span class="n">min_distance</span>
                <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Using cell centers for distance calculation</span>
            <span class="n">cell_x</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">x_center_col</span><span class="p">]</span>
            <span class="n">cell_y</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">y_center_col</span><span class="p">]</span>
            
            <span class="c1"># Calculate distances to all other cells</span>
            <span class="n">others</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cell_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Skip if there are no other cells</span>
                <span class="k">continue</span>
                
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">others</span><span class="p">[</span><span class="n">x_center_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">others</span><span class="p">[</span><span class="n">y_center_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            
            <span class="n">nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                <span class="s1">&#39;nearest_neighbor_distance&#39;</span><span class="p">:</span> <span class="n">min_distance</span>
            <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span></div>


<div class="viewcode-block" id="calculate_cell_density">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_cell_density">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_cell_density</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                          <span class="n">normalize_by_area</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the cell density/crowding for each cell by counting neighbors within a specified radius.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        radius: Radius in pixels to search for neighboring cells</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        normalize_by_area: Whether to normalize count by the search area (True) or return raw counts (False)</span>
<span class="sd">        use_polygons: Whether to use polygon boundaries (True) or cell centers (False) for density calculation</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with cell IDs and their density measurements</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_global_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_local_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns for centroid-based calculation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_center_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_center_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check if we have polygons data if using polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polygon data not available in the Spatioloji object&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a list to store results</span>
    <span class="n">densities</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Calculate the search area (for normalization)</span>
    <span class="n">search_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="n">normalize_by_area</span> <span class="k">else</span> <span class="mi">1</span>
    
    <span class="c1"># If using polygons, create a dictionary of cell polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="c1"># Group polygons by cell</span>
        <span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cell_centers</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">cell_poly_data</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_polygon_for_cell</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
            
            <span class="c1"># Skip if no polygon data found for this cell</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Create a polygon from the points</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">[</span><span class="n">x_poly_col</span><span class="p">],</span> <span class="n">cell_poly_data</span><span class="p">[</span><span class="n">y_poly_col</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for a polygon</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                    <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span>
                    <span class="c1"># Store the centroid for creating the buffer</span>
                    <span class="n">cell_centers</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create polygon for cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># For each cell, count the number of cells within the radius</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">cell_id</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="c1"># Skip if this cell doesn&#39;t have polygon data</span>
            <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">current_polygon</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
            <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">=</span> <span class="n">cell_centers</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
            
            <span class="c1"># Create a circular buffer around the cell centroid</span>
            <span class="n">search_circle</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
            
            <span class="c1"># Count neighboring cells whose polygons intersect with the search circle</span>
            <span class="n">neighbors_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">other_cell_id</span><span class="p">,</span> <span class="n">other_polygon</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">other_cell_id</span> <span class="o">!=</span> <span class="n">cell_id</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">search_circle</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other_polygon</span><span class="p">):</span>
                        <span class="n">neighbors_count</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Normalize by area if requested</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">neighbors_count</span> <span class="o">/</span> <span class="n">search_area</span> <span class="k">if</span> <span class="n">normalize_by_area</span> <span class="k">else</span> <span class="n">neighbors_count</span>
            
            <span class="n">densities</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                <span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="n">density</span><span class="p">,</span>
                <span class="s1">&#39;neighbors_count&#39;</span><span class="p">:</span> <span class="n">neighbors_count</span>
            <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Using cell centers for density calculation</span>
            <span class="n">cell_x</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">x_center_col</span><span class="p">]</span>
            <span class="n">cell_y</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">y_center_col</span><span class="p">]</span>
            
            <span class="c1"># Calculate distances to all other cells</span>
            <span class="n">others</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cell_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Skip if there are no other cells</span>
                <span class="k">continue</span>
                
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">others</span><span class="p">[</span><span class="n">x_center_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">others</span><span class="p">[</span><span class="n">y_center_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">neighbors_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">)</span>
            
            <span class="c1"># Normalize by area if requested</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">neighbors_count</span> <span class="o">/</span> <span class="n">search_area</span> <span class="k">if</span> <span class="n">normalize_by_area</span> <span class="k">else</span> <span class="n">neighbors_count</span>
            
            <span class="n">densities</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                <span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="n">density</span><span class="p">,</span>
                <span class="s1">&#39;neighbors_count&#39;</span><span class="p">:</span> <span class="n">neighbors_count</span>
            <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">densities</span><span class="p">)</span></div>




<span class="c1"># Spatial Pattern Analysis</span>
<div class="viewcode-block" id="calculate_ripleys_k">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_ripleys_k">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_ripleys_k</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_distances</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Ripley&#39;s K function to analyze spatial point patterns with multithreaded permutations.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        max_distance: Maximum distance to calculate K function</span>
<span class="sd">        num_distances: Number of distance points to evaluate (default: 20)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for confidence envelope (0 for none)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distances, K values, L values (normalized K), and optionally confidence envelopes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract point coordinates</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">n_points</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least 2 points to calculate Ripley&#39;s K function&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate the area of the study region</span>
    <span class="c1"># For simplicity, use the bounding box of the points as the study area</span>
    <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span>
    
    <span class="c1"># Define the distances at which to evaluate the K function</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_distances</span><span class="p">)</span>
    
    <span class="c1"># Calculate pairwise distances between all points</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
    
    <span class="c1"># Initialize arrays to store K values and L values</span>
    <span class="n">k_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
    <span class="n">l_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
    
    <span class="c1"># Calculate K function for each distance</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">l_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">continue</span>
        
        <span class="c1"># Count points within distance d of each point</span>
        <span class="n">points_within_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_matrix</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">n_points</span>  <span class="c1"># Subtract n_points to exclude self-counts</span>
        
        <span class="c1"># Calculate K value: (area/n_points^2) * sum(I(dij &lt;= d))</span>
        <span class="n">k_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">*</span> <span class="n">points_within_d</span>
        
        <span class="c1"># Calculate L value: sqrt(K/pi) - d</span>
        <span class="n">l_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">d</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">distances</span><span class="p">,</span>
        <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="n">k_values</span><span class="p">,</span>
        <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="n">l_values</span>
    <span class="p">})</span>
    
    <span class="c1"># If permutations are requested, calculate confidence envelopes using parallelization</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Define a function to calculate K function for a single permutation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_k_for_permutation</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">distances</span><span class="p">):</span>
            <span class="c1"># Set random seed for reproducibility</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Generate random points within the bounding box</span>
            <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">],</span>
                <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Calculate distance matrix for random points</span>
            <span class="n">random_dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">random_points</span><span class="p">)</span>
            <span class="n">random_dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">random_dist_matrix</span><span class="p">)</span>
            
            <span class="c1"># Calculate K and L functions for random pattern</span>
            <span class="n">random_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="n">random_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Count points within distance d of each point</span>
                <span class="n">points_within_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">random_dist_matrix</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">n_points</span>
                
                <span class="c1"># Calculate K value</span>
                <span class="n">random_k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">*</span> <span class="n">points_within_d</span>
                
                <span class="c1"># Calculate L value</span>
                <span class="n">random_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">random_k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">d</span>
            
            <span class="k">return</span> <span class="n">random_k</span><span class="p">,</span> <span class="n">random_l</span>
        
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Run permutations in parallel</span>
        <span class="n">permutation_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_k_for_permutation</span><span class="p">)(</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">distances</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract K and L values from permutation results</span>
        <span class="n">random_k_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">permutation_results</span><span class="p">])</span>
        <span class="n">random_l_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">permutation_results</span><span class="p">])</span>
        
        <span class="c1"># Calculate confidence envelopes (min and max values across permutations)</span>
        <span class="n">k_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">random_k_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">k_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">random_k_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">l_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">random_l_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">l_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">random_l_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add confidence envelopes to result</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;K_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;K_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_high</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;L_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;L_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_high</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_cross_k_function">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_cross_k_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_cross_k_function</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="p">,</span> <span class="n">cell_type1</span><span class="p">,</span> <span class="n">cell_type2</span><span class="p">,</span> 
                              <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_distances</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                              <span class="n">edge_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Ripley&#39;s Cross-K function to analyze spatial relationships between two different cell types.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information</span>
<span class="sd">        cell_type1: First cell type for cross-K analysis</span>
<span class="sd">        cell_type2: Second cell type for cross-K analysis</span>
<span class="sd">        max_distance: Maximum distance to calculate K function (in pixels)</span>
<span class="sd">        num_distances: Number of distance points to evaluate (default: 20)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        edge_correction: Whether to apply edge correction (True) or not (False)</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for confidence envelope (0 for none)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distances, Cross-K values, and confidence envelopes if requested</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get cell type information from AnnData object</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
    <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add cell type information to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Extract cells of the specific types</span>
    <span class="n">cells_type1</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type1</span><span class="p">]</span>
    <span class="n">cells_type2</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type2</span><span class="p">]</span>
    
    <span class="c1"># Check if we have enough cells</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_type1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type1</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_type2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type2</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates for each cell type</span>
    <span class="n">coords1</span> <span class="o">=</span> <span class="n">cells_type1</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">coords2</span> <span class="o">=</span> <span class="n">cells_type2</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Calculate study area</span>
    <span class="n">all_cells</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">cells_type1</span><span class="p">,</span> <span class="n">cells_type2</span><span class="p">])</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">all_cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">all_cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
    
    <span class="c1"># Create study area polygon for edge correction</span>
    <span class="n">study_area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)])</span>
    
    <span class="c1"># Calculate cell densities</span>
    <span class="n">density1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
    <span class="n">density2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords2</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
    
    <span class="c1"># Create distance bins</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_distances</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">distance_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate Cross-K function</span>
    <span class="n">cross_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_distances</span><span class="p">)</span>
    
    <span class="c1"># Count points of type 2 within distance r of each point of type 1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)):</span>
        <span class="n">point1</span> <span class="o">=</span> <span class="n">coords1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Create shapely point for edge correction</span>
        <span class="n">shapely_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_distances</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Upper bound of current distance bin</span>
            
            <span class="c1"># Count points of type 2 within distance r of point1</span>
            <span class="n">dist_to_point1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords2</span> <span class="o">-</span> <span class="n">point1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">points_within_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_to_point1</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
            
            <span class="c1"># Apply edge correction if requested</span>
            <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
                <span class="c1"># Create a circle buffer around the point</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="n">shapely_point</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                
                <span class="c1"># Calculate the fraction of the circle that falls within the study area</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">buffer</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">study_area</span><span class="p">):</span>
                    <span class="c1"># Calculate intersection area</span>
                    <span class="n">intersection</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">study_area</span><span class="p">)</span>
                    <span class="c1"># Calculate edge correction factor</span>
                    <span class="n">edge_correction_factor</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">intersection</span><span class="o">.</span><span class="n">area</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_correction_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
                
                <span class="c1"># Apply edge correction</span>
                <span class="n">points_within_r</span> <span class="o">*=</span> <span class="n">edge_correction_factor</span>
            
            <span class="c1"># Add to Cross-K function</span>
            <span class="n">cross_k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">points_within_r</span>
    
    <span class="c1"># Normalize Cross-K function</span>
    <span class="n">cross_k</span> <span class="o">=</span> <span class="n">cross_k</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)</span> <span class="o">*</span> <span class="n">density2</span><span class="p">)</span>
    
    <span class="c1"># Calculate Cross-L function (normalized version of Cross-K)</span>
    <span class="n">cross_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cross_k</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">distance_centers</span>
    
    <span class="c1"># Calculate theoretical Cross-K under CSR (Complete Spatial Randomness)</span>
    <span class="c1"># For CSR, K(r) = r</span>
    <span class="n">theoretical_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">distance_centers</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="c1"># Calculate difference from CSR</span>
    <span class="n">diff_from_csr</span> <span class="o">=</span> <span class="n">cross_k</span> <span class="o">-</span> <span class="n">theoretical_k</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">distance_centers</span><span class="p">,</span>
        <span class="s1">&#39;cross_k&#39;</span><span class="p">:</span> <span class="n">cross_k</span><span class="p">,</span>
        <span class="s1">&#39;cross_l&#39;</span><span class="p">:</span> <span class="n">cross_l</span><span class="p">,</span>
        <span class="s1">&#39;theoretical_k&#39;</span><span class="p">:</span> <span class="n">theoretical_k</span><span class="p">,</span>
        <span class="s1">&#39;diff_from_csr&#39;</span><span class="p">:</span> <span class="n">diff_from_csr</span>
    <span class="p">})</span>
    
    <span class="c1"># Calculate Monte Carlo confidence envelope if requested</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate Cross-K for random cell distributions</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_cross_k</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">n_points2</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">edge_correction</span><span class="p">,</span> <span class="n">study_area</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Generate random coordinates for type 2 cells</span>
            <span class="n">random_coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span>
                <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">height</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_points2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Calculate Cross-K function for random distribution</span>
            <span class="n">random_cross_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)):</span>
                <span class="n">point1</span> <span class="o">=</span> <span class="n">coords1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Create shapely point for edge correction</span>
                <span class="n">shapely_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Upper bound of current distance bin</span>
                    
                    <span class="c1"># Count random points within distance r of point1</span>
                    <span class="n">dist_to_point1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">random_coords2</span> <span class="o">-</span> <span class="n">point1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">points_within_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_to_point1</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
                    
                    <span class="c1"># Apply edge correction if requested</span>
                    <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
                        <span class="c1"># Create a circle buffer around the point</span>
                        <span class="n">buffer</span> <span class="o">=</span> <span class="n">shapely_point</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        
                        <span class="c1"># Calculate the fraction of the circle that falls within the study area</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">buffer</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">study_area</span><span class="p">):</span>
                            <span class="c1"># Calculate intersection area</span>
                            <span class="n">intersection</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">study_area</span><span class="p">)</span>
                            <span class="c1"># Calculate edge correction factor</span>
                            <span class="n">edge_correction_factor</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">intersection</span><span class="o">.</span><span class="n">area</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">edge_correction_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
                        
                        <span class="c1"># Apply edge correction</span>
                        <span class="n">points_within_r</span> <span class="o">*=</span> <span class="n">edge_correction_factor</span>
                    
                    <span class="c1"># Add to Cross-K function</span>
                    <span class="n">random_cross_k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">points_within_r</span>
            
            <span class="c1"># Normalize Cross-K function</span>
            <span class="n">random_cross_k</span> <span class="o">=</span> <span class="n">random_cross_k</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_points2</span> <span class="o">/</span> <span class="n">area</span><span class="p">))</span>
            
            <span class="k">return</span> <span class="n">random_cross_k</span>
        
        <span class="c1"># Run Monte Carlo simulations in parallel</span>
        <span class="n">mc_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_cross_k</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords2</span><span class="p">),</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">edge_correction</span><span class="p">,</span> <span class="n">study_area</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo simulations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Stack results for easier processing</span>
        <span class="n">mc_cross_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mc_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate confidence envelopes (2.5% and 97.5% percentiles)</span>
        <span class="n">cross_k_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_cross_k</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cross_k_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_cross_k</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Calculate Cross-L function for envelopes</span>
        <span class="n">cross_l_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cross_k_low</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">distance_centers</span>
        <span class="n">cross_l_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cross_k_high</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">distance_centers</span>
        
        <span class="c1"># Add to result DataFrame</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_k_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross_k_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_k_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross_k_high</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_l_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross_l_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_l_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross_l_high</span>
        
        <span class="c1"># Determine if observed Cross-K is significantly different from random</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_k&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_k_high&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_k&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_k_low&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_significant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">]</span>
    
    <span class="c1"># Interpret the Cross-K function</span>
    <span class="c1"># For Cross-K:</span>
    <span class="c1"># - K(r) &gt; r: Cells of type 2 are more clustered around cells of type 1 than expected (attraction)</span>
    <span class="c1"># - K(r) = r: Cells of type 2 are randomly distributed around cells of type 1 (no interaction)</span>
    <span class="c1"># - K(r) &lt; r: Cells of type 2 are more dispersed around cells of type 1 than expected (repulsion)</span>
    <span class="c1"># </span>
    <span class="c1"># For Cross-L:</span>
    <span class="c1"># - L(r) &gt; 0: Attraction</span>
    <span class="c1"># - L(r) = 0: No interaction</span>
    <span class="c1"># - L(r) &lt; 0: Repulsion</span>
    
    <span class="c1"># Add interpretation column</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Random&#39;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_l&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Attraction&#39;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;cross_l&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Repulsion&#39;</span>
    
    <span class="c1"># If we have significance testing, refine the interpretation</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Random (Not Significant)&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Attraction (Significant)&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Repulsion (Significant)&#39;</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Define plot configuration</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;cross_l&#39;</span><span class="p">,</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Cross-L Function: </span><span class="si">{</span><span class="n">cell_type1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">cell_type2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross-L(r)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reference_line&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Add a horizontal line at L(r) = 0</span>
            <span class="s1">&#39;confidence_intervals&#39;</span><span class="p">:</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Add confidence intervals if available</span>
            <span class="s1">&#39;ci_low&#39;</span><span class="p">:</span> <span class="s1">&#39;cross_l_low&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ci_high&#39;</span><span class="p">:</span> <span class="s1">&#39;cross_l_high&#39;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_j_function">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_j_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_j_function</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">edge_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">monte_carlo_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Baddeley&#39;s J-function, which combines G-function and F-function for spatial pattern analysis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        max_distance: Maximum distance to consider (in pixels)</span>
<span class="sd">        num_bins: Number of distance bins for the functions</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        edge_correction: Whether to apply edge correction (True) or not (False)</span>
<span class="sd">        monte_carlo_points: Number of random points to generate for F-function calculation</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for confidence envelope (0 for none)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distances and J-function values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Calculate study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
    
    <span class="c1"># Create study area polygon for edge correction</span>
    <span class="n">study_area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)])</span>
    
    <span class="c1"># Calculate distance bins</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate G-function (nearest neighbor distance distribution)</span>
    <span class="c1"># --------------------------------------------------------------</span>
    
    <span class="c1"># Calculate nearest neighbor distances for each cell</span>
    <span class="n">nn_distances</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Calculate distances to all other cells (excluding self)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Exclude self</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        
        <span class="c1"># Find minimum distance (nearest neighbor)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
    
    <span class="c1"># Apply edge correction for G-function if requested</span>
    <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
        <span class="c1"># Border method edge correction</span>
        <span class="c1"># Adjust distances for points near the boundary</span>
        <span class="n">nn_distances_corrected</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># Calculate distance to nearest boundary</span>
            <span class="n">distance_to_edge</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">,</span>  <span class="c1"># Distance to left edge</span>
                <span class="n">x_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Distance to right edge</span>
                <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">,</span>  <span class="c1"># Distance to bottom edge</span>
                <span class="n">y_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># Distance to top edge</span>
            <span class="p">)</span>
            
            <span class="c1"># If the point is closer to the edge than to its nearest neighbor,</span>
            <span class="c1"># this could be due to edge effects</span>
            <span class="k">if</span> <span class="n">distance_to_edge</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                <span class="c1"># Apply edge correction factor</span>
                <span class="n">correction_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">distance_to_edge</span><span class="p">)</span> <span class="o">/</span> <span class="n">distance_to_edge</span>
                <span class="n">dist_corrected</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">correction_factor</span>
                <span class="n">nn_distances_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_corrected</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nn_distances_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        
        <span class="n">nn_distances</span> <span class="o">=</span> <span class="n">nn_distances_corrected</span>
    
    <span class="c1"># Calculate empirical G-function</span>
    <span class="n">g_empirical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
        <span class="c1"># Count proportion of nearest neighbor distances &lt;= r</span>
        <span class="n">g_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate F-function (empty space function)</span>
    <span class="c1"># ------------------------------------------</span>
    
    <span class="c1"># Generate random points in the study area for F-function</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># For reproducibility</span>
    <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
        <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span>
        <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">],</span>
        <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">monte_carlo_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="c1"># Calculate distance from each random point to the nearest cell</span>
    <span class="n">es_distances</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_points</span><span class="p">)):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">random_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Calculate distances to all cells</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Find minimum distance (nearest cell)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">es_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
    
    <span class="c1"># Apply edge correction for F-function if requested</span>
    <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
        <span class="c1"># Reduced sample edge correction</span>
        <span class="c1"># Only keep random points that are at least max_distance away from the boundary</span>
        <span class="n">filtered_es_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filtered_points</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">es_distances</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">random_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># Calculate distance to nearest boundary</span>
            <span class="n">distance_to_edge</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">,</span>  <span class="c1"># Distance to left edge</span>
                <span class="n">x_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Distance to right edge</span>
                <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">,</span>  <span class="c1"># Distance to bottom edge</span>
                <span class="n">y_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># Distance to top edge</span>
            <span class="p">)</span>
            
            <span class="c1"># Only keep points that are far enough from the edge</span>
            <span class="k">if</span> <span class="n">distance_to_edge</span> <span class="o">&gt;=</span> <span class="n">max_distance</span><span class="p">:</span>
                <span class="n">filtered_es_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">filtered_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        
        <span class="c1"># If we have enough points after filtering, use them</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_es_distances</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">es_distances</span> <span class="o">=</span> <span class="n">filtered_es_distances</span>
            <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If too few points remain, use original points but apply correction</span>
            <span class="n">es_distances_corrected</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">es_distances</span><span class="p">):</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">random_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Calculate distance to nearest boundary</span>
                <span class="n">distance_to_edge</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">,</span>  <span class="c1"># Distance to left edge</span>
                    <span class="n">x_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Distance to right edge</span>
                    <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">,</span>  <span class="c1"># Distance to bottom edge</span>
                    <span class="n">y_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># Distance to top edge</span>
                <span class="p">)</span>
                
                <span class="c1"># Apply correction if needed</span>
                <span class="k">if</span> <span class="n">distance_to_edge</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="n">es_distances_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_to_edge</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">es_distances_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            
            <span class="n">es_distances</span> <span class="o">=</span> <span class="n">es_distances_corrected</span>
    
    <span class="c1"># Calculate empirical F-function</span>
    <span class="n">f_empirical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
        <span class="c1"># Count proportion of empty space distances &lt;= r</span>
        <span class="n">f_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">es_distances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate theoretical functions for CSR</span>
    <span class="c1"># For CSR, G(r) = F(r) = 1 - exp(-r)</span>
    <span class="n">lambda_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
    <span class="n">theoretical_csr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lambda_cells</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bin_centers</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Calculate J-function</span>
    <span class="c1"># J(r) = (1 - G(r)) / (1 - F(r))</span>
    <span class="n">j_empirical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
        <span class="n">g_value</span> <span class="o">=</span> <span class="n">g_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">f_value</span> <span class="o">=</span> <span class="n">f_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Avoid division by zero</span>
        <span class="k">if</span> <span class="n">f_value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">j_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Default to J(r) = 1 (CSR) if F(r) = 1</span>
    
    <span class="c1"># Calculate theoretical J-function for CSR</span>
    <span class="c1"># For CSR, J(r) = 1 for all r</span>
    <span class="n">j_theoretical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">bin_centers</span><span class="p">,</span>
        <span class="s1">&#39;g_empirical&#39;</span><span class="p">:</span> <span class="n">g_empirical</span><span class="p">,</span>
        <span class="s1">&#39;f_empirical&#39;</span><span class="p">:</span> <span class="n">f_empirical</span><span class="p">,</span>
        <span class="s1">&#39;j_empirical&#39;</span><span class="p">:</span> <span class="n">j_empirical</span><span class="p">,</span>
        <span class="s1">&#39;theoretical_csr&#39;</span><span class="p">:</span> <span class="n">theoretical_csr</span><span class="p">,</span>
        <span class="s1">&#39;j_theoretical&#39;</span><span class="p">:</span> <span class="n">j_theoretical</span>
    <span class="p">})</span>
    
    <span class="c1"># Calculate Monte Carlo confidence envelope if requested</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate J-function for random cell distributions</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_j</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">monte_carlo_points</span><span class="p">,</span> <span class="n">edge_correction</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Generate random coordinates for cells</span>
            <span class="n">random_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span>
                <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">height</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Calculate G-function for random distribution</span>
            <span class="n">nn_distances</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_coords</span><span class="p">)):</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">random_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Calculate distances to all other points (excluding self)</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_coords</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Exclude self</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">random_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                
                <span class="c1"># Find minimum distance (nearest neighbor)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                    <span class="n">nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
            
            <span class="c1"># Apply edge correction for G-function if requested</span>
            <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
                <span class="c1"># Simple correction for random simulation</span>
                <span class="n">nn_distances</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nn_distances</span><span class="p">]</span>
            
            <span class="c1"># Calculate empirical G-function</span>
            <span class="n">g_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Count proportion of nearest neighbor distances &lt;= r</span>
                <span class="n">g_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c1"># Generate random points in the study area for F-function</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">10000</span><span class="p">)</span>  <span class="c1"># Different seed for F-function</span>
            <span class="n">random_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span>
                <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">monte_carlo_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Calculate F-function for random distribution</span>
            <span class="n">es_distances</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_points</span><span class="p">)):</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">random_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Calculate distances to all random cells</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">random_coords</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Find minimum distance (nearest cell)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                    <span class="n">es_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
            
            <span class="c1"># Apply edge correction for F-function if requested</span>
            <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
                <span class="c1"># Simple correction for random simulation</span>
                <span class="n">es_distances</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">es_distances</span><span class="p">]</span>
            
            <span class="c1"># Calculate empirical F-function</span>
            <span class="n">f_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Count proportion of empty space distances &lt;= r</span>
                <span class="n">f_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">es_distances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c1"># Calculate J-function</span>
            <span class="n">j_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">g_value</span> <span class="o">=</span> <span class="n">g_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">f_value</span> <span class="o">=</span> <span class="n">f_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Avoid division by zero</span>
                <span class="k">if</span> <span class="n">f_value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">j_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f_value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">j_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
            <span class="k">return</span> <span class="n">j_random</span>
        
        <span class="c1"># Run Monte Carlo simulations in parallel</span>
        <span class="n">mc_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_j</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">monte_carlo_points</span><span class="p">,</span> <span class="n">edge_correction</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo simulations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Stack results for easier processing</span>
        <span class="n">mc_j_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mc_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate confidence envelopes (2.5% and 97.5% percentiles)</span>
        <span class="n">j_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_j_values</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">j_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_j_values</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add to result DataFrame</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j_high</span>
        
        <span class="c1"># Determine if observed J-function is significantly different from random</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_empirical&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_low&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_regular&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_empirical&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_high&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_significant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_regular&#39;</span><span class="p">]</span>
    
    <span class="c1"># Interpret the J-function</span>
    <span class="c1"># For J-function:</span>
    <span class="c1"># - J(r) = 1: Complete Spatial Randomness (CSR)</span>
    <span class="c1"># - J(r) &lt; 1: Clustering (attraction between points)</span>
    <span class="c1"># - J(r) &gt; 1: Regularity/dispersion (repulsion between points)</span>
    
    <span class="c1"># Add interpretation column</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Random&#39;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_empirical&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.95</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Clustered&#39;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_empirical&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.05</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Regular&#39;</span>
    
    <span class="c1"># If we have significance testing, refine the interpretation</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Random (Not Significant)&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Clustered (Significant)&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_regular&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Regular (Significant)&#39;</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Define plot configuration</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;j_empirical&#39;</span><span class="p">,</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;J-function (Baddeley</span><span class="se">\&#39;</span><span class="s1">s)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s2">&quot;All cells&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;J(r)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reference_line&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Add a horizontal line at J(r) = 1</span>
            <span class="s1">&#39;confidence_intervals&#39;</span><span class="p">:</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Add confidence intervals if available</span>
            <span class="s1">&#39;ci_low&#39;</span><span class="p">:</span> <span class="s1">&#39;j_low&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ci_high&#39;</span><span class="p">:</span> <span class="s1">&#39;j_high&#39;</span><span class="p">,</span>
            <span class="s1">&#39;y_min&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Start y-axis at 0</span>
            <span class="s1">&#39;y_max&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;j_empirical&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">)</span>  <span class="c1"># Adjust y-axis based on data</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_g_function">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_g_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_g_function</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">reference_cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                        <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the G-function (nearest neighbor distance distribution function).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        max_distance: Maximum distance to consider (in pixels)</span>
<span class="sd">        num_bins: Number of distance bins for the G-function</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        reference_cell_type: Optional reference cell type for cross-type G-function (None for same type)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        edge_correction: Whether to apply edge correction (True) or not (False)</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for confidence envelope (0 for none)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distances and G-function values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get cell type information if needed</span>
    <span class="n">cross_type</span> <span class="o">=</span> <span class="n">reference_cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">reference_cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type or reference_cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Filter cells based on cell type</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells_target</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells_target</span> <span class="o">=</span> <span class="n">cells</span>
    
    <span class="c1"># For cross-type G-function, extract reference cells</span>
    <span class="k">if</span> <span class="n">reference_cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells_reference</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference_cell_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_reference</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">reference_cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells_reference</span> <span class="o">=</span> <span class="n">cells_target</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords_target</span> <span class="o">=</span> <span class="n">cells_target</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">coords_reference</span> <span class="o">=</span> <span class="n">cells_reference</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Calculate study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
    
    <span class="c1"># Create study area polygon for edge correction</span>
    <span class="n">study_area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)])</span>
    
    <span class="c1"># Calculate distance bins</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate nearest neighbor distances for each target cell</span>
    <span class="n">nn_distances</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_target</span><span class="p">)):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">coords_target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">cross_type</span><span class="p">:</span>
            <span class="c1"># Calculate distances to all reference cells</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords_reference</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Find minimum distance (nearest neighbor)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                <span class="n">nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate distances to all other target cells (excluding self)</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_target</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Exclude self</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            
            <span class="c1"># Find minimum distance (nearest neighbor)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                <span class="n">nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
    
    <span class="c1"># Apply edge correction if requested</span>
    <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
        <span class="c1"># Border method edge correction</span>
        <span class="c1"># Adjust distances for points near the boundary</span>
        <span class="n">nn_distances_corrected</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">coords_target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># Calculate distance to nearest boundary</span>
            <span class="n">distance_to_edge</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">,</span>  <span class="c1"># Distance to left edge</span>
                <span class="n">x_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Distance to right edge</span>
                <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">,</span>  <span class="c1"># Distance to bottom edge</span>
                <span class="n">y_max</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># Distance to top edge</span>
            <span class="p">)</span>
            
            <span class="c1"># If the point is closer to the edge than to its nearest neighbor,</span>
            <span class="c1"># this could be due to edge effects (nearest neighbor might be outside the study area)</span>
            <span class="k">if</span> <span class="n">distance_to_edge</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                <span class="c1"># Apply edge correction factor</span>
                <span class="c1"># This is a simplified approach; more sophisticated methods exist</span>
                <span class="n">correction_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">distance_to_edge</span><span class="p">)</span> <span class="o">/</span> <span class="n">distance_to_edge</span>
                <span class="n">dist_corrected</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">correction_factor</span>
                <span class="n">nn_distances_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_corrected</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nn_distances_corrected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        
        <span class="n">nn_distances</span> <span class="o">=</span> <span class="n">nn_distances_corrected</span>
    
    <span class="c1"># Calculate empirical G-function</span>
    <span class="n">g_empirical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
        <span class="c1"># Count proportion of nearest neighbor distances &lt;= r</span>
        <span class="n">g_empirical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate theoretical G-function for CSR (Complete Spatial Randomness)</span>
    <span class="c1"># For CSR, G(r) = 1 - exp(-r)</span>
    <span class="c1"># where  is the density of points</span>
    
    <span class="k">if</span> <span class="n">cross_type</span><span class="p">:</span>
        <span class="n">lambda_reference</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_reference</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
        <span class="n">g_theoretical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lambda_reference</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bin_centers</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lambda_target</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_target</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
        <span class="n">g_theoretical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lambda_target</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bin_centers</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Calculate the difference from CSR</span>
    <span class="n">g_diff</span> <span class="o">=</span> <span class="n">g_empirical</span> <span class="o">-</span> <span class="n">g_theoretical</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">bin_centers</span><span class="p">,</span>
        <span class="s1">&#39;g_empirical&#39;</span><span class="p">:</span> <span class="n">g_empirical</span><span class="p">,</span>
        <span class="s1">&#39;g_theoretical&#39;</span><span class="p">:</span> <span class="n">g_theoretical</span><span class="p">,</span>
        <span class="s1">&#39;g_diff&#39;</span><span class="p">:</span> <span class="n">g_diff</span>
    <span class="p">})</span>
    
    <span class="c1"># Calculate Monte Carlo confidence envelope if requested</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate G-function for random cell distributions</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_g</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_points_target</span><span class="p">,</span> <span class="n">n_points_reference</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cross_type</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Generate random coordinates</span>
            <span class="k">if</span> <span class="n">cross_type</span><span class="p">:</span>
                <span class="n">random_coords_target</span> <span class="o">=</span> <span class="n">coords_target</span>  <span class="c1"># Keep target cells fixed</span>
                <span class="n">random_coords_reference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span>
                    <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">height</span><span class="p">],</span>
                    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_points_reference</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">random_coords_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span>
                    <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">height</span><span class="p">],</span>
                    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_points_target</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">random_coords_reference</span> <span class="o">=</span> <span class="n">random_coords_target</span>
            
            <span class="c1"># Calculate nearest neighbor distances for each random target cell</span>
            <span class="n">random_nn_distances</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_coords_target</span><span class="p">)):</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">random_coords_target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">cross_type</span><span class="p">:</span>
                    <span class="c1"># Calculate distances to all reference cells</span>
                    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">random_coords_reference</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    
                    <span class="c1"># Find minimum distance (nearest neighbor)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                        <span class="n">random_nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Calculate distances to all other target cells (excluding self)</span>
                    <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_coords_target</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Exclude self</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">random_coords_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    
                    <span class="c1"># Find minimum distance (nearest neighbor)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                        <span class="n">random_nn_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
            
            <span class="c1"># Calculate empirical G-function for random distribution</span>
            <span class="n">g_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Count proportion of nearest neighbor distances &lt;= r</span>
                <span class="n">g_random</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_nn_distances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="k">return</span> <span class="n">g_random</span>
        
        <span class="c1"># Run Monte Carlo simulations in parallel</span>
        <span class="n">mc_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_g</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_target</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_reference</span><span class="p">),</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cross_type</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo simulations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Stack results for easier processing</span>
        <span class="n">mc_g_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mc_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate confidence envelopes (2.5% and 97.5% percentiles)</span>
        <span class="n">g_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_g_values</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">g_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_g_values</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add to result DataFrame</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_high</span>
        
        <span class="c1"># Determine if observed G-function is significantly different from random</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_empirical&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_high&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_empirical&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_low&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_significant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">]</span>
    
    <span class="c1"># Interpret the G-function</span>
    <span class="c1"># For G-function:</span>
    <span class="c1"># - G(r) &gt; theoretical G(r): Cells are more clustered than expected (shorter nearest neighbor distances)</span>
    <span class="c1"># - G(r) = theoretical G(r): Cells follow CSR (random distribution)</span>
    <span class="c1"># - G(r) &lt; theoretical G(r): Cells are more dispersed than expected (longer nearest neighbor distances)</span>
    
    <span class="c1"># Add interpretation column</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Random&#39;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_diff&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Clustered&#39;</span>
    <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;g_diff&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Dispersed&#39;</span>
    
    <span class="c1"># If we have significance testing, refine the interpretation</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Random (Not Significant)&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Clustered (Significant)&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Dispersed (Significant)&#39;</span>
    
    <span class="c1"># Calculate summary statistics</span>
    <span class="n">mean_nn_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span>
    <span class="n">median_nn_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span>
    <span class="n">min_nn_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">max_nn_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">std_nn_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">nn_distances</span><span class="p">)</span>
    
    <span class="c1"># Add summary statistics to the result</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mean_nn_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_nn_distance</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;median_nn_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_nn_distance</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;min_nn_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_nn_distance</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;max_nn_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_nn_distance</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;std_nn_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_nn_distance</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Define plot configuration</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;g_empirical&#39;</span><span class="p">,</span>
            <span class="s1">&#39;y2&#39;</span><span class="p">:</span> <span class="s1">&#39;g_theoretical&#39;</span><span class="p">,</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;G-function (Nearest Neighbor Distance Distribution)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s2">&quot;All&quot;</span><span class="si">}</span><span class="s1">, Reference: </span><span class="si">{</span><span class="n">reference_cell_type</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s2">&quot;Same&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;G(r)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;confidence_intervals&#39;</span><span class="p">:</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Add confidence intervals if available</span>
            <span class="s1">&#39;ci_low&#39;</span><span class="p">:</span> <span class="s1">&#39;g_low&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ci_high&#39;</span><span class="p">:</span> <span class="s1">&#39;g_high&#39;</span><span class="p">,</span>
            <span class="s1">&#39;legend&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Empirical G(r)&#39;</span><span class="p">,</span> <span class="s1">&#39;Theoretical G(r) for CSR&#39;</span><span class="p">]</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_pair_correlation_function">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_pair_correlation_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_pair_correlation_function</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> 
                                       <span class="n">cell_type1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                       <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">monte_carlo</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Pair Correlation Function (PCF) to analyze spatial relationships between cells at different distances.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        max_distance: Maximum distance to consider for the PCF (in pixels)</span>
<span class="sd">        num_bins: Number of distance bins to use</span>
<span class="sd">        cell_type1: Optional first cell type for type-specific PCF (None for all cells)</span>
<span class="sd">        cell_type2: Optional second cell type for type-specific PCF (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type1/2 is provided)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        edge_correction: Whether to apply edge correction (True) or not (False)</span>
<span class="sd">        n_jobs: Number of parallel jobs (-1 for all processors)</span>
<span class="sd">        monte_carlo: Number of Monte Carlo simulations for confidence envelope (0 for none)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distances and PCF values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># Optional, for progress tracking</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polygon</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get cell type information if needed</span>
    <span class="k">if</span> <span class="n">cell_type1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cell_type2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type1 or cell_type2 is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell types if specified</span>
    <span class="n">points1</span> <span class="o">=</span> <span class="n">cells</span>
    <span class="n">points2</span> <span class="o">=</span> <span class="n">cells</span>
    
    <span class="k">if</span> <span class="n">cell_type1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">points1</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type1</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">cell_type2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">points2</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type2</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords1</span> <span class="o">=</span> <span class="n">points1</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">coords2</span> <span class="o">=</span> <span class="n">points2</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Create distance bins</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Calculate study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
    
    <span class="c1"># Create study area polygon for edge correction</span>
    <span class="n">study_area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)])</span>
    
    <span class="c1"># Determine if we&#39;re doing a cross-type or same-type analysis</span>
    <span class="n">same_points</span> <span class="o">=</span> <span class="n">cell_type1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cell_type2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cell_type1</span> <span class="o">==</span> <span class="n">cell_type2</span>
    
    <span class="c1"># Calculate density (points per unit area)</span>
    <span class="n">density1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
    <span class="n">density2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords2</span><span class="p">)</span> <span class="o">/</span> <span class="n">area</span>
    
    <span class="c1"># Function to count pairs in each distance bin</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_pairs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">same_points</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">edge_correction</span><span class="p">):</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Get coordinates of the reference point</span>
        <span class="n">x_i</span><span class="p">,</span> <span class="n">y_i</span> <span class="o">=</span> <span class="n">coords1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Calculate distances to all other points</span>
        <span class="k">if</span> <span class="n">same_points</span><span class="p">:</span>
            <span class="c1"># Skip self-comparisons for same-type PCF</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coords2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">coords2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Remove self-distance (which is 0)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coords2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">coords2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Count pairs in each distance bin</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dists</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
                
            <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">bin_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bin_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Apply edge correction if requested</span>
            <span class="k">if</span> <span class="n">edge_correction</span><span class="p">:</span>
                <span class="c1"># Border method edge correction</span>
                <span class="c1"># Calculate the fraction of the circle with radius &#39;dist&#39; that falls within the study area</span>
                
                <span class="c1"># For simplicity, use a geometric approximation:</span>
                <span class="c1"># If the distance to any edge is less than the current distance,</span>
                <span class="c1"># the circle is partially outside the study area</span>
                <span class="n">dist_to_left</span> <span class="o">=</span> <span class="n">x_i</span> <span class="o">-</span> <span class="n">x_min</span>
                <span class="n">dist_to_right</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_i</span>
                <span class="n">dist_to_bottom</span> <span class="o">=</span> <span class="n">y_i</span> <span class="o">-</span> <span class="n">y_min</span>
                <span class="n">dist_to_top</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_i</span>
                
                <span class="n">min_edge_dist</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist_to_left</span><span class="p">,</span> <span class="n">dist_to_right</span><span class="p">,</span> <span class="n">dist_to_bottom</span><span class="p">,</span> <span class="n">dist_to_top</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">min_edge_dist</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="c1"># Approximate the fraction of circle inside the study area</span>
                    <span class="c1"># This is a simplified approach; for high accuracy, one would need to</span>
                    <span class="c1"># calculate the actual intersection area</span>
                    <span class="k">if</span> <span class="n">min_edge_dist</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Point is on or outside the boundary - skip</span>
                        <span class="k">continue</span>
                        
                    <span class="c1"># Simple geometric approximation</span>
                    <span class="n">fraction_inside</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">min_edge_dist</span> <span class="o">/</span> <span class="n">dist</span><span class="p">)</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fraction_inside</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
            
            <span class="n">counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        
        <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">weights</span>
    
    <span class="c1"># Process all points in parallel</span>
    <span class="n">num_workers</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">n_jobs</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">count_pairs</span><span class="p">)(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">same_points</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">edge_correction</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Calculating PCF&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="c1"># Combine results</span>
    <span class="n">all_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">all_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">counts</span><span class="p">,</span> <span class="n">weights</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">all_counts</span> <span class="o">+=</span> <span class="n">counts</span>
        <span class="n">all_weights</span> <span class="o">+=</span> <span class="n">weights</span>
    
    <span class="c1"># Calculate PCF</span>
    <span class="c1"># For a completely random (Poisson) process, PCF = 1 at all distances</span>
    <span class="c1"># PCF &gt; 1 indicates clustering at that distance</span>
    <span class="c1"># PCF &lt; 1 indicates repulsion at that distance</span>
    
    <span class="c1"># Expected number of points in annular ring for CSR:</span>
    <span class="c1"># E[n(r)] = lambda * 2r * dr</span>
    <span class="c1"># where lambda is intensity (points per unit area)</span>
    
    <span class="c1"># Calculate PCF = observed / expected</span>
    <span class="k">if</span> <span class="n">same_points</span><span class="p">:</span>
        <span class="c1"># For same-type PCF, expected counts are based on intensity of single pattern</span>
        <span class="n">intensity_product</span> <span class="o">=</span> <span class="n">density1</span> <span class="o">*</span> <span class="n">density1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For cross-type PCF, expected counts are based on product of intensities</span>
        <span class="n">intensity_product</span> <span class="o">=</span> <span class="n">density1</span> <span class="o">*</span> <span class="n">density2</span>
    
    <span class="c1"># Calculate areas of annular rings</span>
    <span class="n">ring_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Expected counts in each bin under CSR</span>
    <span class="n">expected_counts</span> <span class="o">=</span> <span class="n">intensity_product</span> <span class="o">*</span> <span class="n">ring_areas</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">)</span>
    
    <span class="c1"># Calculate PCF values, handling edge correction weights</span>
    <span class="n">pcf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expected_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_correction</span> <span class="ow">and</span> <span class="n">all_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Apply edge correction weights</span>
                <span class="n">pcf_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">all_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">expected_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pcf_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">expected_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pcf_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">bin_centers</span><span class="p">,</span>
        <span class="s1">&#39;pcf&#39;</span><span class="p">:</span> <span class="n">pcf_values</span><span class="p">,</span>
        <span class="s1">&#39;observed_count&#39;</span><span class="p">:</span> <span class="n">all_counts</span><span class="p">,</span>
        <span class="s1">&#39;expected_count&#39;</span><span class="p">:</span> <span class="n">expected_counts</span><span class="p">,</span>
        <span class="s1">&#39;bin_width&#39;</span><span class="p">:</span> <span class="n">bin_widths</span>
    <span class="p">})</span>
    
    <span class="c1"># Calculate Monte Carlo confidence envelope if requested</span>
    <span class="k">if</span> <span class="n">monte_carlo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Function to simulate a random point pattern</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">simulate_random_pattern</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">height</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        
        <span class="c1"># Function to calculate PCF for a random pattern</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_pcf</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_points1</span><span class="p">,</span> <span class="n">n_points2</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">same_points</span><span class="p">):</span>
            <span class="c1"># Generate random patterns</span>
            <span class="n">random_coords1</span> <span class="o">=</span> <span class="n">simulate_random_pattern</span><span class="p">(</span><span class="n">n_points1</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">same_points</span><span class="p">:</span>
                <span class="n">random_coords2</span> <span class="o">=</span> <span class="n">random_coords1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">random_coords2</span> <span class="o">=</span> <span class="n">simulate_random_pattern</span><span class="p">(</span><span class="n">n_points2</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">seed</span> <span class="o">+</span> <span class="mi">10000</span><span class="p">)</span>
            
            <span class="c1"># Count pairs for this random pattern</span>
            <span class="n">all_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_coords1</span><span class="p">)):</span>
                <span class="n">x_i</span><span class="p">,</span> <span class="n">y_i</span> <span class="o">=</span> <span class="n">random_coords1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Calculate distances to all other points</span>
                <span class="k">if</span> <span class="n">same_points</span><span class="p">:</span>
                    <span class="c1"># Skip self-comparisons for same-type PCF</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">random_coords2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">random_coords2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Remove self-distance (which is 0)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">random_coords2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">random_coords2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                
                <span class="c1"># Count pairs in each distance bin</span>
                <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bin_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">all_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Calculate PCF values</span>
            <span class="n">pcf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Expected counts in each bin under CSR</span>
            <span class="n">ring_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">same_points</span><span class="p">:</span>
                <span class="n">expected_counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_points1</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_points1</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="n">ring_areas</span> <span class="o">*</span> <span class="n">n_points1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expected_counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_points1</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_points2</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="n">ring_areas</span> <span class="o">*</span> <span class="n">n_points1</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expected_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pcf_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">expected_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pcf_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
            <span class="k">return</span> <span class="n">pcf_values</span>
        
        <span class="c1"># Run Monte Carlo simulations in parallel</span>
        <span class="n">mc_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_pcf</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords2</span><span class="p">),</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">same_points</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">monte_carlo</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo simulations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Combine Monte Carlo results</span>
        <span class="n">mc_pcf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mc_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate confidence envelope (5th and 95th percentiles)</span>
        <span class="n">pcf_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_pcf_values</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pcf_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_pcf_values</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add to result DataFrame</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;pcf_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcf_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;pcf_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcf_high</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;significant_clustering&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;pcf&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;pcf_high&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;significant_repulsion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;pcf&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;pcf_low&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">result</span></div>





<span class="c1"># Cell Type Interaction Analysis</span>
<div class="viewcode-block" id="calculate_cell_type_correlation">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_cell_type_correlation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_cell_type_correlation</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> 
                                   <span class="n">distance_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate spatial correlation between different cell types as a function of distance,</span>
<span class="sd">    using multithreading for performance optimization.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information</span>
<span class="sd">        max_distance: Maximum distance to consider for correlation analysis (in pixels)</span>
<span class="sd">        distance_bins: Number of distance bins to divide the analysis into</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        n_jobs: Number of parallel jobs (-1 for all processors)</span>
<span class="sd">        batch_size: Number of cells to process in each parallel batch</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing:</span>
<span class="sd">            - pair_counts: DataFrame with counts of cell type pairs in each distance bin</span>
<span class="sd">            - correlation_matrix: Dict of correlation matrices for each distance bin</span>
<span class="sd">            - distance_bins: Array of distance bin edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># Optional, for progress tracking</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get cell type information from AnnData object</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
    <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add cell type information to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Drop cells without cell type information</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">])</span>
    
    <span class="c1"># Get the unique cell types</span>
    <span class="n">cell_types</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="n">n_types</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)</span>
    
    <span class="c1"># Create a mapping from cell type to index</span>
    <span class="n">type_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)}</span>
    
    <span class="c1"># Create distance bins</span>
    <span class="n">distance_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">distance_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">distance_bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">distance_bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Extract coordinates and cell type indices</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">type_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">type_to_idx</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]])</span>
    
    <span class="c1"># Determine number of cores to use</span>
    <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
    
    <span class="c1"># Function to process a batch of cells</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_cell_batch</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">type_indices</span><span class="p">,</span> <span class="n">distance_bin_edges</span><span class="p">,</span> <span class="n">n_types</span><span class="p">):</span>
        <span class="c1"># Initialize local pair counts matrix</span>
        <span class="n">local_pair_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">distance_bins</span><span class="p">,</span> <span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
        
        <span class="c1"># Get the total number of cells</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        
        <span class="c1"># Process each cell in the batch</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">end_idx</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)):</span>
            <span class="c1"># Calculate distances from this cell to all other cells</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Process each other cell</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cells</span><span class="p">):</span>
                <span class="c1"># Skip self-comparisons and pairs we&#39;ve already counted (to avoid double counting)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="n">d</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                
                <span class="c1"># Skip if distance is greater than max_distance</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_distance</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="c1"># Determine which distance bin this pair falls into</span>
                <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">distance_bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                
                <span class="c1"># Clip to ensure within valid bin range</span>
                <span class="k">if</span> <span class="n">bin_idx</span> <span class="o">&gt;=</span> <span class="n">distance_bins</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="c1"># Get cell types of the pair</span>
                <span class="n">type_i</span> <span class="o">=</span> <span class="n">type_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">type_j</span> <span class="o">=</span> <span class="n">type_indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                
                <span class="c1"># Increment the count for this cell type pair</span>
                <span class="n">local_pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">type_i</span><span class="p">,</span> <span class="n">type_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">local_pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">type_j</span><span class="p">,</span> <span class="n">type_i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Count in both directions</span>
        
        <span class="k">return</span> <span class="n">local_pair_counts</span>
    
    <span class="c1"># Create batches of cells to process</span>
    <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
    <span class="n">batch_starts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">))</span>
    
    <span class="c1"># Process batches in parallel</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">process_cell_batch</span><span class="p">)(</span>
            <span class="n">start_idx</span><span class="p">,</span>
            <span class="n">start_idx</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">type_indices</span><span class="p">,</span>
            <span class="n">distance_bin_edges</span><span class="p">,</span>
            <span class="n">n_types</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">start_idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">batch_starts</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing cell batches&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="c1"># Combine results from all batches</span>
    <span class="n">pair_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">distance_bins</span><span class="p">,</span> <span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">batch_result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">pair_counts</span> <span class="o">+=</span> <span class="n">batch_result</span>
    
    <span class="c1"># Calculate correlation matrices for each distance bin</span>
    <span class="n">correlation_matrices</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distance_bins</span><span class="p">):</span>
        <span class="c1"># Create a correlation matrix for this distance bin</span>
        <span class="n">bin_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
        
        <span class="c1"># Calculate expected counts based on overall frequency</span>
        <span class="n">total_counts</span> <span class="o">=</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">total_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Get marginal counts for each cell type</span>
            <span class="n">type_counts</span> <span class="o">=</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Calculate expected counts for each pair assuming independence</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">type_counts</span><span class="p">,</span> <span class="n">type_counts</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_counts</span>
            
            <span class="c1"># Calculate correlation as (observed - expected) / expected</span>
            <span class="c1"># Add a small value to avoid division by zero</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">bin_corr</span> <span class="o">=</span> <span class="p">(</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">expected</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
                
            <span class="c1"># Replace NaN values with 0</span>
            <span class="n">bin_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">bin_corr</span><span class="p">)</span>
        
        <span class="n">correlation_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_corr</span><span class="p">)</span>
    
    <span class="c1"># Convert pair_counts to a DataFrame for easier interpretation</span>
    <span class="n">pair_counts_df</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distance_bins</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">type_i_idx</span><span class="p">,</span> <span class="n">type_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">type_j_idx</span><span class="p">,</span> <span class="n">type_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">type_i_idx</span><span class="p">,</span> <span class="n">type_j_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pair_counts_df</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;distance_bin&#39;</span><span class="p">:</span> <span class="n">bin_idx</span><span class="p">,</span>
                        <span class="s1">&#39;distance_min&#39;</span><span class="p">:</span> <span class="n">distance_bin_edges</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],</span>
                        <span class="s1">&#39;distance_max&#39;</span><span class="p">:</span> <span class="n">distance_bin_edges</span><span class="p">[</span><span class="n">bin_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;distance_center&#39;</span><span class="p">:</span> <span class="n">distance_bin_centers</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],</span>
                        <span class="s1">&#39;cell_type_1&#39;</span><span class="p">:</span> <span class="n">type_i</span><span class="p">,</span>
                        <span class="s1">&#39;cell_type_2&#39;</span><span class="p">:</span> <span class="n">type_j</span><span class="p">,</span>
                        <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">type_i_idx</span><span class="p">,</span> <span class="n">type_j_idx</span><span class="p">],</span>
                        <span class="s1">&#39;correlation&#39;</span><span class="p">:</span> <span class="n">correlation_matrices</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">][</span><span class="n">type_i_idx</span><span class="p">,</span> <span class="n">type_j_idx</span><span class="p">]</span>
                    <span class="p">})</span>
    
    <span class="n">pair_counts_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pair_counts_df</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping bin index to correlation matrix for easier access</span>
    <span class="n">corr_matrix_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s1">&#39;bin_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">_dist_</span><span class="si">{</span><span class="n">distance_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">px&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">correlation_matrices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distance_bins</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;pair_counts&#39;</span><span class="p">:</span> <span class="n">pair_counts_df</span><span class="p">,</span>
        <span class="s1">&#39;correlation_matrices&#39;</span><span class="p">:</span> <span class="n">corr_matrix_dict</span><span class="p">,</span>
        <span class="s1">&#39;distance_bins&#39;</span><span class="p">:</span> <span class="n">distance_bin_edges</span><span class="p">,</span>
        <span class="s1">&#39;cell_types&#39;</span><span class="p">:</span> <span class="n">cell_types</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="calculate_colocation_quotient">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_colocation_quotient">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_colocation_quotient</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="p">,</span>
                                 <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">bootstrap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Colocation Quotient (CLQ) to measure spatial relationships between different cell types.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information</span>
<span class="sd">        distance_threshold: Maximum distance (in pixels) to consider cells as co-located</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        normalize: Whether to normalize the CLQ by the overall cell type frequencies</span>
<span class="sd">        bootstrap: Number of bootstrap iterations for confidence interval (0 for no bootstrapping)</span>
<span class="sd">        confidence: Confidence level for bootstrap interval (default: 0.95)</span>
<span class="sd">        n_jobs: Number of parallel jobs for bootstrap calculation (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with CLQ values for each pair of cell types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearSegmentedColormap</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get cell type information from AnnData object</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
    <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add cell type information to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Drop cells without cell type information</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">])</span>
    
    <span class="c1"># Get the unique cell types</span>
    <span class="n">cell_types</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="n">n_types</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates and cell types</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Calculate distance matrix</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Create a matrix to count co-located pairs</span>
    <span class="n">coloc_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
    
    <span class="c1"># Calculate co-location for each cell type pair</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">type_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
        <span class="c1"># Get indices of cells of type i</span>
        <span class="n">indices_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">types</span> <span class="o">==</span> <span class="n">type_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">type_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
            <span class="c1"># Get indices of cells of type j</span>
            <span class="n">indices_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">types</span> <span class="o">==</span> <span class="n">type_j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Skip if either cell type has no cells</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># Count co-located pairs</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Same cell type</span>
                <span class="c1"># Subtract the number of cells to account for self-pairs</span>
                <span class="n">n_pairs</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="n">indices_i</span><span class="p">:</span>
                    <span class="n">n_pairs</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">indices_j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">coloc_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_pairs</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># Divide by 2 to avoid double counting</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Different cell types</span>
                <span class="c1"># Count pairs where distance &lt;= threshold</span>
                <span class="n">n_pairs</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="n">indices_i</span><span class="p">:</span>
                    <span class="n">n_pairs</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">indices_j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">)</span>
                <span class="n">coloc_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_pairs</span>
    
    <span class="c1"># Calculate Colocation Quotient</span>
    <span class="c1"># CLQ = observed co-locations / expected co-locations</span>
    
    <span class="c1"># Calculate overall cell type frequencies</span>
    <span class="n">type_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">types</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">])</span>
    <span class="n">type_freqs</span> <span class="o">=</span> <span class="n">type_counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">type_counts</span><span class="p">)</span>
    
    <span class="c1"># Calculate expected co-locations based on cell type frequencies</span>
    <span class="n">expected_coloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="c1"># Calculate total number of valid cell pairs</span>
        <span class="n">total_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coloc_counts</span><span class="p">)</span>
        
        <span class="c1"># Calculate expected co-locations based on random mixing</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="c1"># Expected number of same-type pairs</span>
                    <span class="n">expected_coloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_pairs</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Expected number of different-type pairs</span>
                    <span class="n">expected_coloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_pairs</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Simple counts without normalization</span>
        <span class="n">expected_coloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">coloc_counts</span><span class="p">)</span>
    
    <span class="c1"># Calculate CLQ</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">clq</span> <span class="o">=</span> <span class="n">coloc_counts</span> <span class="o">/</span> <span class="n">expected_coloc</span>
    
    <span class="c1"># Replace NaN values with 0 (when expected count is 0)</span>
    <span class="n">clq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">clq</span><span class="p">)</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">clq_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">clq</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">)</span>
    
    <span class="c1"># Calculate log2 CLQ for more intuitive visualization</span>
    <span class="n">log2_clq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">clq</span><span class="p">)</span>
    <span class="n">log2_clq_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">log2_clq</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">)</span>
    
    <span class="c1"># Replace infinite values with a large value for visualization</span>
    <span class="n">log2_clq_df</span> <span class="o">=</span> <span class="n">log2_clq_df</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">])</span>
    
    <span class="c1"># Calculate bootstrap confidence intervals if requested</span>
    <span class="k">if</span> <span class="n">bootstrap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate CLQ for a bootstrap sample</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">bootstrap_clq</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="p">,</span> <span class="n">normalize</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Resample cells with replacement</span>
            <span class="n">bootstrap_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bootstrap_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">bootstrap_indices</span><span class="p">]</span>
            <span class="n">bootstrap_types</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">bootstrap_indices</span><span class="p">]</span>
            
            <span class="c1"># Calculate distance matrix for bootstrap sample</span>
            <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">))</span>
            
            <span class="c1"># Create a matrix to count co-located pairs</span>
            <span class="n">coloc_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
            
            <span class="c1"># Calculate co-location for each cell type pair</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">type_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
                <span class="c1"># Get indices of cells of type i</span>
                <span class="n">indices_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bootstrap_types</span> <span class="o">==</span> <span class="n">type_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">type_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
                    <span class="c1"># Get indices of cells of type j</span>
                    <span class="n">indices_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bootstrap_types</span> <span class="o">==</span> <span class="n">type_j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    
                    <span class="c1"># Skip if either cell type has no cells</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Count co-located pairs</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Same cell type</span>
                        <span class="c1"># Subtract the number of cells to account for self-pairs</span>
                        <span class="n">n_pairs</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="n">indices_i</span><span class="p">:</span>
                            <span class="n">n_pairs</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">indices_j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">coloc_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_pairs</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># Divide by 2 to avoid double counting</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Different cell types</span>
                        <span class="c1"># Count pairs where distance &lt;= threshold</span>
                        <span class="n">n_pairs</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="n">indices_i</span><span class="p">:</span>
                            <span class="n">n_pairs</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">indices_j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">)</span>
                        <span class="n">coloc_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_pairs</span>
            
            <span class="c1"># Calculate overall cell type frequencies</span>
            <span class="n">type_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bootstrap_types</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">])</span>
            <span class="n">type_freqs</span> <span class="o">=</span> <span class="n">type_counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">type_counts</span><span class="p">)</span>
            
            <span class="c1"># Calculate expected co-locations based on cell type frequencies</span>
            <span class="n">expected_coloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="c1"># Calculate total number of valid cell pairs</span>
                <span class="n">total_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coloc_counts</span><span class="p">)</span>
                
                <span class="c1"># Calculate expected co-locations based on random mixing</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="c1"># Expected number of same-type pairs</span>
                            <span class="n">expected_coloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_pairs</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Expected number of different-type pairs</span>
                            <span class="n">expected_coloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_pairs</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">type_freqs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Simple counts without normalization</span>
                <span class="n">expected_coloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">coloc_counts</span><span class="p">)</span>
            
            <span class="c1"># Calculate CLQ</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">clq</span> <span class="o">=</span> <span class="n">coloc_counts</span> <span class="o">/</span> <span class="n">expected_coloc</span>
            
            <span class="c1"># Replace NaN values with 0</span>
            <span class="n">clq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">clq</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">clq</span>
        
        <span class="c1"># Run bootstrap iterations in parallel</span>
        <span class="n">bootstrap_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">bootstrap_clq</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="p">,</span> <span class="n">normalize</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Bootstrap iterations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Convert list of arrays to 3D array</span>
        <span class="n">bootstrap_clqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bootstrap_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate confidence intervals</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">confidence</span>
        <span class="n">lower_percentile</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">upper_percentile</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
        
        <span class="n">clq_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
        <span class="n">clq_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
                <span class="n">clq_lower</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bootstrap_clqs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">lower_percentile</span><span class="p">)</span>
                <span class="n">clq_upper</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bootstrap_clqs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">upper_percentile</span><span class="p">)</span>
        
        <span class="c1"># Create DataFrames for confidence intervals</span>
        <span class="n">clq_lower_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">clq_lower</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">)</span>
        <span class="n">clq_upper_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">clq_upper</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">)</span>
        
        <span class="c1"># Calculate statistical significance</span>
        <span class="c1"># CLQ is significantly different from 1 if confidence interval doesn&#39;t include 1</span>
        <span class="n">significance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
                <span class="c1"># Check if confidence interval includes 1</span>
                <span class="n">significance</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">clq_lower</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">clq_upper</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        
        <span class="n">significance_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">significance</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">clq_lower_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clq_upper_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">significance_df</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Interpret CLQ values</span>
    <span class="n">interpretation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_types</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_types</span><span class="p">):</span>
            <span class="n">clq_value</span> <span class="o">=</span> <span class="n">clq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">clq_value</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Strong co-location&quot;</span>
            <span class="k">elif</span> <span class="n">clq_value</span> <span class="o">&gt;</span> <span class="mf">1.2</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Moderate co-location&quot;</span>
            <span class="k">elif</span> <span class="n">clq_value</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Slight co-location&quot;</span>
            <span class="k">elif</span> <span class="n">clq_value</span> <span class="o">&gt;=</span> <span class="mf">0.8</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Random mixing&quot;</span>
            <span class="k">elif</span> <span class="n">clq_value</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Slight avoidance&quot;</span>
            <span class="k">elif</span> <span class="n">clq_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Strong avoidance&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interpretation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;No interaction detected&quot;</span>
    
    <span class="n">interpretation_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">interpretation</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">)</span>
    
    <span class="c1"># Create a composite result object</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;clq&#39;</span><span class="p">:</span> <span class="n">clq_df</span><span class="p">,</span>
        <span class="s1">&#39;log2_clq&#39;</span><span class="p">:</span> <span class="n">log2_clq_df</span><span class="p">,</span>
        <span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="n">interpretation_df</span><span class="p">,</span>
        <span class="s1">&#39;distance_threshold&#39;</span><span class="p">:</span> <span class="n">distance_threshold</span><span class="p">,</span>
        <span class="s1">&#39;normalize&#39;</span><span class="p">:</span> <span class="n">normalize</span><span class="p">,</span>
        <span class="s1">&#39;n_cell_types&#39;</span><span class="p">:</span> <span class="n">n_types</span><span class="p">,</span>
        <span class="s1">&#39;cell_types&#39;</span><span class="p">:</span> <span class="n">cell_types</span><span class="p">,</span>
        <span class="s1">&#39;cell_type_frequencies&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">type_freqs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cell_types</span><span class="p">),</span>
        <span class="s1">&#39;clq_lower&#39;</span><span class="p">:</span> <span class="n">clq_lower_df</span><span class="p">,</span>
        <span class="s1">&#39;clq_upper&#39;</span><span class="p">:</span> <span class="n">clq_upper_df</span><span class="p">,</span>
        <span class="s1">&#39;significance&#39;</span><span class="p">:</span> <span class="n">significance_df</span>
    <span class="p">}</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Custom diverging colormap: blue (avoidance) -&gt; white (random) -&gt; red (co-location)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span>
            <span class="s1">&#39;custom_diverging&#39;</span><span class="p">,</span>
            <span class="p">[</span><span class="s1">&#39;#0000FF&#39;</span><span class="p">,</span> <span class="s1">&#39;#AAAAFF&#39;</span><span class="p">,</span> <span class="s1">&#39;#FFFFFF&#39;</span><span class="p">,</span> <span class="s1">&#39;#FFAAAA&#39;</span><span class="p">,</span> <span class="s1">&#39;#FF0000&#39;</span><span class="p">],</span>
            <span class="n">N</span><span class="o">=</span><span class="mi">256</span>
        <span class="p">)</span>
        
        <span class="c1"># Define plot configuration</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">log2_clq_df</span><span class="p">,</span>
            <span class="s1">&#39;colormap&#39;</span><span class="p">:</span> <span class="n">cmap</span><span class="p">,</span>
            <span class="s1">&#39;vmin&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># log2(0.25) - strong avoidance</span>
            <span class="s1">&#39;vmax&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>   <span class="c1"># log2(4) - strong co-location</span>
            <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># log2(1) - random mixing</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Co-location Quotient (log2 scale)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Distance threshold: </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s1"> pixels&#39;</span><span class="p">,</span>
            <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell Type&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell Type&#39;</span><span class="p">,</span>
            <span class="s1">&#39;text_format&#39;</span><span class="p">:</span> <span class="s1">&#39;.2f&#39;</span>
        <span class="p">}</span>
        
        <span class="c1"># Plot annotations for statistical significance if available</span>
        <span class="k">if</span> <span class="n">significance_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_config</span><span class="p">[</span><span class="s1">&#39;annotations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">significance_df</span>
            <span class="n">plot_config</span><span class="p">[</span><span class="s1">&#39;annotation_text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_proximity_analysis">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_proximity_analysis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_proximity_analysis</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">reference_cell_type</span><span class="p">,</span> <span class="n">target_cell_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">max_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distance_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                               <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">edge_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate proximity analysis to quantify spatial relationships between specific cell types.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        reference_cell_type: Cell type to use as reference points</span>
<span class="sd">        target_cell_types: List of cell types to analyze proximity to (None for all cell types)</span>
<span class="sd">        max_distance: Maximum distance to consider (in pixels) (None for auto-determination)</span>
<span class="sd">        distance_bins: Number of distance bins for proximity function</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        use_polygons: Whether to use cell polygons (True) or cell centers (False) for distance calculations</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for significance testing (0 for none)</span>
<span class="sd">        edge_correction: Whether to apply edge correction for boundary effects (True) or not (False)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing proximity statistics and spatial relationships between cell types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
    
    <span class="c1"># Validate input parameters</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided for proximity analysis&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_global_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_local_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_center_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_center_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check if we have polygons data if using polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polygon data not available in the Spatioloji object&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get cell type information</span>
    <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add cell type information to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Drop cells without cell type information</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">])</span>
    
    <span class="c1"># Validate reference cell type</span>
    <span class="k">if</span> <span class="n">reference_cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reference cell type &#39;</span><span class="si">{</span><span class="n">reference_cell_type</span><span class="si">}</span><span class="s2">&#39; not found in the data&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine target cell types</span>
    <span class="k">if</span> <span class="n">target_cell_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_cell_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Validate target cell types</span>
        <span class="n">invalid_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">target_cell_types</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">invalid_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following target cell types were not found in the data: </span><span class="si">{</span><span class="n">invalid_types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract reference and target cells</span>
    <span class="n">reference_cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference_cell_type</span><span class="p">]</span>
    <span class="n">target_cells_by_type</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ct</span><span class="p">]</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">target_cell_types</span><span class="p">}</span>
    
    <span class="c1"># Check if we have enough reference cells</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_cells</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not enough cells of reference type &#39;</span><span class="si">{</span><span class="n">reference_cell_type</span><span class="si">}</span><span class="s2">&#39; (need at least 3)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check if we have enough target cells for each type</span>
    <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">target_cells</span> <span class="ow">in</span> <span class="n">target_cells_by_type</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_cells</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not enough cells of target type &#39;</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s2">&#39; (need at least 3)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">reference_coords</span> <span class="o">=</span> <span class="n">reference_cells</span><span class="p">[[</span><span class="n">x_center_col</span><span class="p">,</span> <span class="n">y_center_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">target_coords_by_type</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="n">tc</span><span class="p">[[</span><span class="n">x_center_col</span><span class="p">,</span> <span class="n">y_center_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> 
                           <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">target_cells_by_type</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="c1"># Create polygons if using polygons</span>
    <span class="n">reference_polygons</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">target_polygons_by_type</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">target_cell_types</span><span class="p">}</span>
    
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="c1"># Create polygons for reference cells</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">reference_cells</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cell_id</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>
            <span class="n">cell_poly_data</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_polygon_for_cell</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
            
            <span class="c1"># Skip if no polygon data for this cell</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Create polygon</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">[</span><span class="n">x_poly_col</span><span class="p">],</span> <span class="n">cell_poly_data</span><span class="p">[</span><span class="n">y_poly_col</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for a polygon</span>
                    <span class="n">reference_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create polygon for reference cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Create polygons for target cells</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">target_cells_by_type</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">tc</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">cell_id</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>
                <span class="n">cell_poly_data</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_polygon_for_cell</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
                
                <span class="c1"># Skip if no polygon data for this cell</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="c1"># Create polygon</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">[</span><span class="n">x_poly_col</span><span class="p">],</span> <span class="n">cell_poly_data</span><span class="p">[</span><span class="n">y_poly_col</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for a polygon</span>
                        <span class="n">target_polygons_by_type</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create polygon for target cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine study area for edge correction and random point generation</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_center_col</span><span class="p">,</span> <span class="n">y_center_col</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_center_col</span><span class="p">,</span> <span class="n">y_center_col</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
    
    <span class="c1"># Create study area polygon for edge correction</span>
    <span class="n">study_area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span> <span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)])</span>
    
    <span class="c1"># Determine maximum distance if not specified</span>
    <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use one-quarter of the study area diagonal as default</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">width</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">height</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
    
    <span class="c1"># Create distance bins</span>
    <span class="n">distance_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">distance_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">distance_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">distance_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Function to calculate distances between reference and target cells</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_distances</span><span class="p">(</span><span class="n">reference_cells</span><span class="p">,</span> <span class="n">target_cells</span><span class="p">,</span> <span class="n">use_polygons</span><span class="p">,</span> <span class="n">reference_polygons</span><span class="p">,</span> <span class="n">target_polygons</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="c1"># Calculate distances between polygons</span>
            <span class="k">for</span> <span class="n">ref_id</span><span class="p">,</span> <span class="n">ref_polygon</span> <span class="ow">in</span> <span class="n">reference_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">target_id</span><span class="p">,</span> <span class="n">target_polygon</span> <span class="ow">in</span> <span class="n">target_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Calculate distance between polygons</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">ref_polygon</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">target_polygon</span><span class="p">)</span>
                        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Error calculating distance between </span><span class="si">{</span><span class="n">ref_id</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate distances between cell centers</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_cells</span><span class="p">)):</span>
                <span class="n">ref_point</span> <span class="o">=</span> <span class="n">reference_cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_cells</span><span class="p">)):</span>
                    <span class="n">target_point</span> <span class="o">=</span> <span class="n">target_cells</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    
                    <span class="c1"># Calculate Euclidean distance</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ref_point</span> <span class="o">-</span> <span class="n">target_point</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
    
    <span class="c1"># Calculate proximity function for each target cell type</span>
    <span class="n">proximity_stats</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">target_cell_types</span><span class="p">:</span>
        <span class="c1"># Skip self-comparisons if reference and target are the same</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="o">==</span> <span class="n">reference_cell_type</span><span class="p">:</span>
            <span class="k">continue</span>
            
        <span class="c1"># Get target coordinates</span>
        <span class="n">target_coords</span> <span class="o">=</span> <span class="n">target_coords_by_type</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span>
        
        <span class="c1"># Calculate distances</span>
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">calculate_distances</span><span class="p">(</span>
                <span class="n">reference_cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">target_cells_by_type</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="n">reference_polygons</span><span class="p">,</span>
                <span class="n">target_polygons_by_type</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">calculate_distances</span><span class="p">(</span>
                <span class="n">reference_coords</span><span class="p">,</span>
                <span class="n">target_coords</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span>
            <span class="p">)</span>
        
        <span class="c1"># Calculate proximity function</span>
        <span class="c1"># This is the cumulative distribution of distances (similar to G-function)</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">distance_edges</span><span class="p">)</span>
        <span class="n">cumulative_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        
        <span class="c1"># Normalize by the number of reference-target pairs</span>
        <span class="n">n_ref</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_cells</span><span class="p">)</span>
        <span class="n">n_target</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_cells_by_type</span><span class="p">[</span><span class="n">ct</span><span class="p">])</span>
        <span class="n">n_pairs</span> <span class="o">=</span> <span class="n">n_ref</span> <span class="o">*</span> <span class="n">n_target</span>
        
        <span class="c1"># Apply edge correction if requested</span>
        <span class="k">if</span> <span class="n">edge_correction</span> <span class="ow">and</span> <span class="n">n_pairs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Calculate area of buffer at each distance</span>
            <span class="n">buffer_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="c1"># Calculate proportion of buffer area inside study area for edge distances</span>
            <span class="c1"># This is a simple approximation; more sophisticated methods exist</span>
            <span class="n">edge_correction_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buffer_areas</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="c1"># Simple correction based on buffer area and study area overlap</span>
                <span class="n">buffer_area</span> <span class="o">=</span> <span class="n">buffer_areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># Approximate correction factor as ratio of areas</span>
                <span class="n">edge_correction_factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">area</span> <span class="o">/</span> <span class="n">buffer_area</span><span class="p">)</span>
            
            <span class="c1"># Apply correction to cumulative histogram</span>
            <span class="n">cumulative_hist</span> <span class="o">=</span> <span class="n">cumulative_hist</span> <span class="o">/</span> <span class="n">edge_correction_factors</span>
            
        <span class="c1"># Normalize by total count</span>
        <span class="k">if</span> <span class="n">n_pairs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normalized_function</span> <span class="o">=</span> <span class="n">cumulative_hist</span> <span class="o">/</span> <span class="n">n_pairs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalized_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cumulative_hist</span><span class="p">)</span>
        
        <span class="c1"># Calculate theoretical function for Complete Spatial Randomness (CSR)</span>
        <span class="c1"># For CSR, G(r) = 1 - exp(-lambda * pi * r^2)</span>
        <span class="c1"># where lambda is the intensity of the target point process</span>
        <span class="n">intensity</span> <span class="o">=</span> <span class="n">n_target</span> <span class="o">/</span> <span class="n">area</span>
        <span class="n">theoretical_function</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">intensity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">distance_centers</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Calculate difference from CSR</span>
        <span class="n">diff_from_csr</span> <span class="o">=</span> <span class="n">normalized_function</span> <span class="o">-</span> <span class="n">theoretical_function</span>
        
        <span class="c1"># Calculate summary statistics</span>
        <span class="n">nearest_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distances</span><span class="p">)[:</span><span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))]</span>
        <span class="n">mean_nearest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nearest_distances</span><span class="p">)</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Store results</span>
        <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;reference_type&#39;</span><span class="p">:</span> <span class="n">reference_cell_type</span><span class="p">,</span>
            <span class="s1">&#39;target_type&#39;</span><span class="p">:</span> <span class="n">ct</span><span class="p">,</span>
            <span class="s1">&#39;n_reference&#39;</span><span class="p">:</span> <span class="n">n_ref</span><span class="p">,</span>
            <span class="s1">&#39;n_target&#39;</span><span class="p">:</span> <span class="n">n_target</span><span class="p">,</span>
            <span class="s1">&#39;distances&#39;</span><span class="p">:</span> <span class="n">distances</span><span class="p">,</span>
            <span class="s1">&#39;distance_edges&#39;</span><span class="p">:</span> <span class="n">distance_edges</span><span class="p">,</span>
            <span class="s1">&#39;distance_centers&#39;</span><span class="p">:</span> <span class="n">distance_centers</span><span class="p">,</span>
            <span class="s1">&#39;proximity_function&#39;</span><span class="p">:</span> <span class="n">normalized_function</span><span class="p">,</span>
            <span class="s1">&#39;theoretical_function&#39;</span><span class="p">:</span> <span class="n">theoretical_function</span><span class="p">,</span>
            <span class="s1">&#39;diff_from_csr&#39;</span><span class="p">:</span> <span class="n">diff_from_csr</span><span class="p">,</span>
            <span class="s1">&#39;min_distance&#39;</span><span class="p">:</span> <span class="n">min_distance</span><span class="p">,</span>
            <span class="s1">&#39;mean_nearest&#39;</span><span class="p">:</span> <span class="n">mean_nearest</span>
        <span class="p">}</span>
    
    <span class="c1"># Calculate Monte Carlo significance if requested</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to generate random points</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">generate_random_points</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_min</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">height</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">])</span>
        
        <span class="c1"># Function to calculate proximity function for random points</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_proximity</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_reference</span><span class="p">,</span> <span class="n">n_target</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> 
                                    <span class="n">distance_edges</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">edge_correction</span><span class="p">,</span> <span class="n">study_area</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Generate random coordinates</span>
            <span class="n">random_ref</span> <span class="o">=</span> <span class="n">generate_random_points</span><span class="p">(</span><span class="n">n_reference</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">random_target</span> <span class="o">=</span> <span class="n">generate_random_points</span><span class="p">(</span><span class="n">n_target</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
            
            <span class="c1"># Calculate distances between random points</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">calculate_distances</span><span class="p">(</span><span class="n">random_ref</span><span class="p">,</span> <span class="n">random_target</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            
            <span class="c1"># Calculate proximity function</span>
            <span class="n">hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">distance_edges</span><span class="p">)</span>
            <span class="n">cumulative_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
            
            <span class="c1"># Apply edge correction if requested</span>
            <span class="k">if</span> <span class="n">edge_correction</span> <span class="ow">and</span> <span class="n">n_reference</span> <span class="o">*</span> <span class="n">n_target</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Calculate area of buffer at each distance</span>
                <span class="n">buffer_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span>
                
                <span class="c1"># Calculate proportion of buffer area inside study area for edge distances</span>
                <span class="n">edge_correction_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buffer_areas</span><span class="p">))</span>
                
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="c1"># Simple correction based on buffer area and study area overlap</span>
                    <span class="n">buffer_area</span> <span class="o">=</span> <span class="n">buffer_areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># Approximate correction factor as ratio of areas</span>
                    <span class="n">edge_correction_factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">area</span> <span class="o">/</span> <span class="n">buffer_area</span><span class="p">)</span>
                
                <span class="c1"># Apply correction to cumulative histogram</span>
                <span class="n">cumulative_hist</span> <span class="o">=</span> <span class="n">cumulative_hist</span> <span class="o">/</span> <span class="n">edge_correction_factors</span>
            
            <span class="c1"># Normalize by total count</span>
            <span class="k">if</span> <span class="n">n_reference</span> <span class="o">*</span> <span class="n">n_target</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">normalized_function</span> <span class="o">=</span> <span class="n">cumulative_hist</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_reference</span> <span class="o">*</span> <span class="n">n_target</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">normalized_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cumulative_hist</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">normalized_function</span>
        
        <span class="c1"># Calculate random proximity functions for each target cell type</span>
        <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">target_cell_types</span><span class="p">:</span>
            <span class="c1"># Skip self-comparisons</span>
            <span class="k">if</span> <span class="n">ct</span> <span class="o">==</span> <span class="n">reference_cell_type</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Get counts</span>
            <span class="n">n_ref</span> <span class="o">=</span> <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;n_reference&#39;</span><span class="p">]</span>
            <span class="n">n_target</span> <span class="o">=</span> <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;n_target&#39;</span><span class="p">]</span>
            
            <span class="c1"># Run permutations in parallel</span>
            <span class="n">random_functions</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_proximity</span><span class="p">)(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">n_ref</span><span class="p">,</span> <span class="n">n_target</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> 
                    <span class="n">distance_edges</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">edge_correction</span><span class="p">,</span> <span class="n">study_area</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Monte Carlo simulations for </span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert to numpy array</span>
            <span class="n">random_functions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_functions</span><span class="p">)</span>
            
            <span class="c1"># Calculate confidence envelopes</span>
            <span class="n">low_envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">random_functions</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">high_envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">random_functions</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Determine if observed function is significantly different from CSR</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;proximity_function&#39;</span><span class="p">]</span>
            <span class="n">is_clustered</span> <span class="o">=</span> <span class="n">observed</span> <span class="o">&gt;</span> <span class="n">high_envelope</span>
            <span class="n">is_dispersed</span> <span class="o">=</span> <span class="n">observed</span> <span class="o">&lt;</span> <span class="n">low_envelope</span>
            
            <span class="c1"># Add to results</span>
            <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;low_envelope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">low_envelope</span>
            <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;high_envelope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">high_envelope</span>
            <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;is_clustered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_clustered</span>
            <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;is_dispersed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_dispersed</span>
            <span class="n">proximity_stats</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;is_significant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">is_clustered</span><span class="p">,</span> <span class="n">is_dispersed</span><span class="p">)</span>
    
    <span class="c1"># Calculate attraction/repulsion scores</span>
    <span class="n">attraction_scores</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="n">proximity_stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Calculate attraction score as average difference from CSR</span>
        <span class="c1"># Positive scores indicate attraction, negative scores indicate repulsion</span>
        <span class="n">attraction_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;diff_from_csr&#39;</span><span class="p">])</span>
        
        <span class="c1"># Determine if attraction/repulsion is significant</span>
        <span class="k">if</span> <span class="s1">&#39;is_significant&#39;</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
            <span class="n">is_significant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;is_significant&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no Monte Carlo simulations, use heuristic</span>
            <span class="n">is_significant</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">attraction_score</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span>
        
        <span class="c1"># Store attraction score</span>
        <span class="n">attraction_scores</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;reference_type&#39;</span><span class="p">:</span> <span class="n">reference_cell_type</span><span class="p">,</span>
            <span class="s1">&#39;target_type&#39;</span><span class="p">:</span> <span class="n">ct</span><span class="p">,</span>
            <span class="s1">&#39;attraction_score&#39;</span><span class="p">:</span> <span class="n">attraction_score</span><span class="p">,</span>
            <span class="s1">&#39;is_significant&#39;</span><span class="p">:</span> <span class="n">is_significant</span><span class="p">,</span>
            <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="s1">&#39;Random&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_significant</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;Attraction&#39;</span> <span class="k">if</span> <span class="n">attraction_score</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Repulsion&#39;</span><span class="p">)</span>
        <span class="p">}</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="n">plot_config</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Create a multi-line plot of proximity functions</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Proximity Analysis from </span><span class="si">{</span><span class="n">reference_cell_type</span><span class="si">}</span><span class="s1"> to Other Cell Types&#39;</span><span class="p">,</span>
            <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Proximity Function G(r)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reference_line&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># No reference line</span>
            <span class="s1">&#39;multi_line&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># Multiple lines on one plot</span>
            <span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>
        
        <span class="c1"># Add a line for each target cell type</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="n">proximity_stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;distance_centers&#39;</span><span class="p">],</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;proximity_function&#39;</span><span class="p">],</span>
                <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">reference_cell_type</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;theoretical&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;theoretical_function&#39;</span><span class="p">]</span>  <span class="c1"># Add theoretical line</span>
            <span class="p">}</span>
            
            <span class="c1"># Add confidence envelopes if available</span>
            <span class="k">if</span> <span class="s1">&#39;low_envelope&#39;</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
                <span class="n">line</span><span class="p">[</span><span class="s1">&#39;low_envelope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;low_envelope&#39;</span><span class="p">]</span>
                <span class="n">line</span><span class="p">[</span><span class="s1">&#39;high_envelope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;high_envelope&#39;</span><span class="p">]</span>
            
            <span class="n">plot_config</span><span class="p">[</span><span class="s1">&#39;lines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    
    <span class="c1"># Create summary DataFrame of attraction scores</span>
    <span class="n">attraction_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">attraction_scores</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    
    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;proximity_stats&#39;</span><span class="p">:</span> <span class="n">proximity_stats</span><span class="p">,</span>
        <span class="s1">&#39;attraction_scores&#39;</span><span class="p">:</span> <span class="n">attraction_df</span><span class="p">,</span>
        <span class="s1">&#39;max_distance&#39;</span><span class="p">:</span> <span class="n">max_distance</span><span class="p">,</span>
        <span class="s1">&#39;reference_cell_type&#39;</span><span class="p">:</span> <span class="n">reference_cell_type</span><span class="p">,</span>
        <span class="s1">&#39;target_cell_types&#39;</span><span class="p">:</span> <span class="n">target_cell_types</span><span class="p">,</span>
        <span class="s1">&#39;plot_config&#39;</span><span class="p">:</span> <span class="n">plot_config</span>
    <span class="p">}</span></div>






<span class="c1"># Heterogeneity and Clustering</span>
<div class="viewcode-block" id="calculate_morisita_index">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_morisita_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_morisita_index</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                            <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
                            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Morisita&#39;s Index of Dispersion to analyze the spatial distribution pattern,</span>
<span class="sd">    with multithreaded bootstrap confidence interval calculation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        grid_size: Size of the grid cells in pixels for quadrat counting</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        bootstrap: Number of bootstrap iterations for confidence interval (0 for no bootstrapping)</span>
<span class="sd">        confidence: Confidence level for bootstrap interval (default: 0.95)</span>
<span class="sd">        n_jobs: Number of parallel jobs for bootstrap calculation (-1 for all processors)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing Morisita&#39;s index and related statistics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># Optional, for progress tracking</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Determine the boundaries of the study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Create grid cells (quadrats)</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
    <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
    
    <span class="c1"># Count cells in each quadrat</span>
    <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">y_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># Create a 2D histogram of cell counts per quadrat</span>
    <span class="n">quadrat_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">x_idx</span> <span class="o">=</span> <span class="n">x_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y_idx</span> <span class="o">=</span> <span class="n">y_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">):</span>
            <span class="n">quadrat_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># Flatten the array for calculations</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">quadrat_counts</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    
    <span class="c1"># Remove empty quadrats (Morisita&#39;s index calculation should only use non-empty quadrats)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Calculate Morisita&#39;s index</span>
    <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">num_quadrats</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">num_quadrats</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">num_points</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;morisita_index&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="s1">&#39;Not enough data for calculation&#39;</span><span class="p">,</span>
            <span class="s1">&#39;num_points&#39;</span><span class="p">:</span> <span class="n">num_points</span><span class="p">,</span>
            <span class="s1">&#39;num_quadrats&#39;</span><span class="p">:</span> <span class="n">num_quadrats</span><span class="p">,</span>
            <span class="s1">&#39;bootstrap_results&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    
    <span class="c1"># Calculate Morisita&#39;s index: Id = Q * (n_i(n_i-1)) / (N(N-1))</span>
    <span class="c1"># where Q is number of quadrats, n_i is count in quadrat i, and N is total count</span>
    <span class="n">sum_ni_ni_minus_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span> <span class="o">*</span> <span class="p">(</span><span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">morisita_index</span> <span class="o">=</span> <span class="n">num_quadrats</span> <span class="o">*</span> <span class="n">sum_ni_ni_minus_1</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Calculate standardized Morisita index (Ip)</span>
    <span class="c1"># This scales the index to a range from -1 to +1</span>
    <span class="c1"># with 0 representing a random distribution</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">num_points</span> <span class="o">/</span> <span class="n">num_quadrats</span>  <span class="c1"># Expected count per quadrat under CSR</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    
    <span class="c1"># Calculate chi-square statistic</span>
    <span class="n">chi_square</span> <span class="o">=</span> <span class="n">num_quadrats</span> <span class="o">*</span> <span class="n">variance</span> <span class="o">/</span> <span class="n">mu</span>
    
    <span class="c1"># Calculate standardized Morisita index</span>
    <span class="k">if</span> <span class="n">morisita_index</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># Pattern is clumped</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="p">(</span><span class="n">chi_square</span> <span class="o">-</span> <span class="n">num_quadrats</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">num_points</span> <span class="o">*</span> <span class="n">num_quadrats</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_quadrats</span><span class="p">)</span>
        <span class="n">standardized_index</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">morisita_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Pattern is uniform</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">chi_square</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_quadrats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">standardized_index</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">morisita_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Interpret the index</span>
    <span class="k">if</span> <span class="n">morisita_index</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">interpretation</span> <span class="o">=</span> <span class="s2">&quot;Uniform distribution&quot;</span>
    <span class="k">elif</span> <span class="n">morisita_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">interpretation</span> <span class="o">=</span> <span class="s2">&quot;Random distribution&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interpretation</span> <span class="o">=</span> <span class="s2">&quot;Clustered distribution&quot;</span>
    
    <span class="c1"># Calculate bootstrap confidence interval if requested, using multithreading</span>
    <span class="n">bootstrap_results</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">bootstrap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Define a function to compute a single bootstrap sample</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">compute_bootstrap_sample</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>  <span class="c1"># Set seed for reproducibility</span>
            
            <span class="c1"># Resample points with replacement</span>
            <span class="n">bootstrap_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bootstrap_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">bootstrap_sample</span><span class="p">]</span>
            
            <span class="c1"># Count cells in each quadrat for this bootstrap sample</span>
            <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">y_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># Create a 2D histogram of cell counts per quadrat</span>
            <span class="n">bootstrap_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">)):</span>
                <span class="n">x_idx</span> <span class="o">=</span> <span class="n">x_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">y_idx</span> <span class="o">=</span> <span class="n">y_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">):</span>
                    <span class="n">bootstrap_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Flatten and remove empty quadrats</span>
            <span class="n">b_counts</span> <span class="o">=</span> <span class="n">bootstrap_counts</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">b_counts</span> <span class="o">=</span> <span class="n">b_counts</span><span class="p">[</span><span class="n">b_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_counts</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
                
            <span class="c1"># Calculate Morisita&#39;s index for this bootstrap sample</span>
            <span class="n">b_num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">)</span>
            <span class="n">b_num_quadrats</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_counts</span><span class="p">)</span>
            <span class="n">b_sum_ni_ni_minus_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b_counts</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Check for division by zero</span>
            <span class="k">if</span> <span class="n">b_num_points</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">b_num_quadrats</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
                
            <span class="n">b_index</span> <span class="o">=</span> <span class="n">b_num_quadrats</span> <span class="o">*</span> <span class="n">b_sum_ni_ni_minus_1</span> <span class="o">/</span> <span class="p">(</span><span class="n">b_num_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            
            <span class="k">return</span> <span class="n">b_index</span>
        
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Run bootstrap iterations in parallel</span>
        <span class="n">bootstrap_indices</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">compute_bootstrap_sample</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Bootstrap iterations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Filter out None values</span>
        <span class="n">bootstrap_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">bootstrap_indices</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        
        <span class="c1"># Calculate confidence interval</span>
        <span class="k">if</span> <span class="n">bootstrap_indices</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">confidence</span>
            <span class="n">lower_percentile</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">upper_percentile</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">ci_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bootstrap_indices</span><span class="p">,</span> <span class="n">lower_percentile</span><span class="p">)</span>
            <span class="n">ci_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bootstrap_indices</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="p">)</span>
            
            <span class="n">bootstrap_results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;bootstrap_samples&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bootstrap_indices</span><span class="p">),</span>
                <span class="s1">&#39;confidence_level&#39;</span><span class="p">:</span> <span class="n">confidence</span><span class="p">,</span>
                <span class="s1">&#39;confidence_interval&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">ci_lower</span><span class="p">,</span> <span class="n">ci_upper</span><span class="p">),</span>
                <span class="s1">&#39;bootstrap_mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bootstrap_indices</span><span class="p">),</span>
                <span class="s1">&#39;bootstrap_std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">bootstrap_indices</span><span class="p">)</span>
            <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;morisita_index&#39;</span><span class="p">:</span> <span class="n">morisita_index</span><span class="p">,</span>
        <span class="s1">&#39;standardized_index&#39;</span><span class="p">:</span> <span class="n">standardized_index</span><span class="p">,</span>
        <span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="n">interpretation</span><span class="p">,</span>
        <span class="s1">&#39;chi_square&#39;</span><span class="p">:</span> <span class="n">chi_square</span><span class="p">,</span>
        <span class="s1">&#39;num_points&#39;</span><span class="p">:</span> <span class="n">num_points</span><span class="p">,</span>
        <span class="s1">&#39;num_quadrats&#39;</span><span class="p">:</span> <span class="n">num_quadrats</span><span class="p">,</span>
        <span class="s1">&#39;grid_size&#39;</span><span class="p">:</span> <span class="n">grid_size</span><span class="p">,</span>
        <span class="s1">&#39;bootstrap_results&#39;</span><span class="p">:</span> <span class="n">bootstrap_results</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="calculate_quadrat_variance">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_quadrat_variance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_quadrat_variance</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">min_grid_size</span><span class="p">,</span> <span class="n">max_grid_size</span><span class="p">,</span> <span class="n">num_sizes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                              <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                              <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate how variance of cell counts changes with quadrat size (quadrat variance analysis).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        min_grid_size: Minimum size of the grid cells in pixels</span>
<span class="sd">        max_grid_size: Maximum size of the grid cells in pixels</span>
<span class="sd">        num_sizes: Number of different grid sizes to test</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        n_jobs: Number of parallel jobs (-1 for all processors)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with grid sizes and corresponding variance metrics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># Optional, for progress tracking</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Determine the boundaries of the study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Generate grid sizes to test</span>
    <span class="n">grid_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_grid_size</span><span class="p">,</span> <span class="n">max_grid_size</span><span class="p">,</span> <span class="n">num_sizes</span><span class="p">)</span>
    
    <span class="c1"># Determine number of cores to use</span>
    <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
    
    <span class="c1"># Function to process a single grid size</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_grid_size</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">):</span>
        <span class="c1"># Create grid for this size</span>
        <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        
        <span class="c1"># Count cells in each quadrat</span>
        <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">y_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="c1"># Create a 2D histogram of cell counts per quadrat</span>
        <span class="n">quadrat_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="n">x_idx</span> <span class="o">=</span> <span class="n">x_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">y_idx</span> <span class="o">=</span> <span class="n">y_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">):</span>
                <span class="n">quadrat_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Flatten the array for calculations</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">quadrat_counts</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1"># Calculate metrics</span>
        <span class="n">mean_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        
        <span class="c1"># Calculate variance-to-mean ratio (VMR) or Index of Dispersion</span>
        <span class="n">vmr</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">/</span> <span class="n">mean_count</span> <span class="k">if</span> <span class="n">mean_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Calculate other metrics</span>
        <span class="c1"># 1. Lloyd&#39;s Index of Patchiness</span>
        <span class="n">lloyds_index</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">variance</span> <span class="o">-</span> <span class="n">mean_count</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mean_count</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">mean_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># 2. Green&#39;s Index (ranges from -1/(n-1) to 1)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        <span class="n">greens_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">variance</span> <span class="o">/</span> <span class="n">mean_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">mean_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># 3. Quadrat occupancy (proportion of quadrats with at least one cell)</span>
        <span class="n">occupancy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;grid_size&#39;</span><span class="p">:</span> <span class="n">grid_size</span><span class="p">,</span>
            <span class="s1">&#39;mean_count&#39;</span><span class="p">:</span> <span class="n">mean_count</span><span class="p">,</span>
            <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">variance</span><span class="p">,</span>
            <span class="s1">&#39;vmr&#39;</span><span class="p">:</span> <span class="n">vmr</span><span class="p">,</span>  <span class="c1"># Variance-to-Mean Ratio</span>
            <span class="s1">&#39;lloyds_index&#39;</span><span class="p">:</span> <span class="n">lloyds_index</span><span class="p">,</span>
            <span class="s1">&#39;greens_index&#39;</span><span class="p">:</span> <span class="n">greens_index</span><span class="p">,</span>
            <span class="s1">&#39;occupancy&#39;</span><span class="p">:</span> <span class="n">occupancy</span><span class="p">,</span>
            <span class="s1">&#39;num_quadrats&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">),</span>
            <span class="s1">&#39;num_occupied_quadrats&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s1">&#39;max_count&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">counts</span><span class="p">),</span>
            <span class="s1">&#39;quadrat_area&#39;</span><span class="p">:</span> <span class="n">grid_size</span><span class="o">**</span><span class="mi">2</span>
        <span class="p">}</span>
    
    <span class="c1"># Process all grid sizes in parallel</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">process_grid_size</span><span class="p">)(</span>
            <span class="n">grid_size</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">grid_size</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">grid_sizes</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing grid sizes&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="c1"># Combine results into a DataFrame</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    
    <span class="c1"># Calculate normalized variance (to help compare across scales)</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;normalized_variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;mean_count&#39;</span><span class="p">]</span>
    
    <span class="c1"># Calculate expected Poisson variance (which equals the mean)</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;expected_variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;mean_count&#39;</span><span class="p">]</span>
    
    <span class="c1"># Calculate the Log-Log relationship (often used to identify fractal patterns)</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;log_grid_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;grid_size&#39;</span><span class="p">])</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;log_variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">])</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;log_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;mean_count&#39;</span><span class="p">])</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;log_vmr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;vmr&#39;</span><span class="p">])</span>
    
    <span class="c1"># Add interpretation column</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpret_vmr</span><span class="p">(</span><span class="n">vmr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vmr</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Unknown&quot;</span>
        <span class="k">elif</span> <span class="n">vmr</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">:</span>  <span class="c1"># Allow for some error in random patterns</span>
            <span class="k">return</span> <span class="s2">&quot;Uniform&quot;</span>
        <span class="k">elif</span> <span class="n">vmr</span> <span class="o">&lt;=</span> <span class="mf">1.1</span><span class="p">:</span>  <span class="c1"># Allow for some error in random patterns</span>
            <span class="k">return</span> <span class="s2">&quot;Random (Poisson)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Clustered&quot;</span>
    
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;pattern&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;vmr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">interpret_vmr</span><span class="p">)</span>
    
    <span class="c1"># Create a summary of the quadrat variance analysis</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_df</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Calculate slope of log-log relationship between variance and grid size</span>
        <span class="c1"># This is related to the fractal dimension of the pattern</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;log_grid_size&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;log_variance&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">,</span> <span class="s1">&#39;log_grid_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">,</span> <span class="s1">&#39;log_variance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            
            <span class="c1"># Simple linear regression</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
            
            <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;slope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">slope</span>
    
    <span class="c1"># Sort by grid size</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;grid_size&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result_df</span></div>


<div class="viewcode-block" id="calculate_spatial_entropy">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_entropy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_spatial_entropy</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entropy_type</span><span class="o">=</span><span class="s1">&#39;shannon&#39;</span><span class="p">,</span>
                             <span class="n">normalization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate spatial entropy to quantify the randomness in spatial distribution of cells.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        grid_size: Size of the grid cells in pixels for quadrat-based entropy calculation</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        entropy_type: Type of entropy to calculate (&#39;shannon&#39;, &#39;renyi&#39;, &#39;tsallis&#39;)</span>
<span class="sd">        normalization: Whether to normalize entropy by the maximum possible value</span>
<span class="sd">        bootstrap: Number of bootstrap iterations for confidence interval (0 for no bootstrapping)</span>
<span class="sd">        n_jobs: Number of parallel jobs for bootstrap calculation (-1 for all processors)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing entropy values and related statistics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Determine the boundaries of the study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Create grid cells (quadrats)</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
    <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
    
    <span class="c1"># Count cells in each quadrat</span>
    <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">y_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># Create a 2D histogram of cell counts per quadrat</span>
    <span class="n">quadrat_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">x_idx</span> <span class="o">=</span> <span class="n">x_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y_idx</span> <span class="o">=</span> <span class="n">y_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">):</span>
            <span class="n">quadrat_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># Flatten the array for calculations</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">quadrat_counts</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    
    <span class="c1"># Calculate total number of cells</span>
    <span class="n">total_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    
    <span class="c1"># Calculate probability for each quadrat (cell proportion)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">total_cells</span>
    
    <span class="c1"># Remove quadrats with zero counts</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="n">probs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Function to calculate different types of entropy</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_entropy</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">entropy_type</span> <span class="o">==</span> <span class="s1">&#39;shannon&#39;</span><span class="p">:</span>
            <span class="c1"># Shannon entropy: -sum(p * log(p))</span>
            <span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span>
            
            <span class="c1"># Maximum possible entropy for normalization</span>
            <span class="k">if</span> <span class="n">normalization</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
                <span class="n">max_entropy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">entropy</span> <span class="o">/</span> <span class="n">max_entropy</span> <span class="k">if</span> <span class="n">max_entropy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">entropy</span>
                
        <span class="k">elif</span> <span class="n">entropy_type</span> <span class="o">==</span> <span class="s1">&#39;renyi&#39;</span><span class="p">:</span>
            <span class="c1"># Renyi entropy (alpha=2): -log(sum(p^2))</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Can be parameterized if needed</span>
            <span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="o">**</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span>
            
            <span class="c1"># Maximum possible entropy for normalization</span>
            <span class="k">if</span> <span class="n">normalization</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
                <span class="n">max_entropy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">entropy</span> <span class="o">/</span> <span class="n">max_entropy</span> <span class="k">if</span> <span class="n">max_entropy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">entropy</span>
                
        <span class="k">elif</span> <span class="n">entropy_type</span> <span class="o">==</span> <span class="s1">&#39;tsallis&#39;</span><span class="p">:</span>
            <span class="c1"># Tsallis entropy: (1 - sum(p^q)) / (q - 1)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Can be parameterized if needed</span>
            <span class="n">entropy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="o">**</span><span class="n">q</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Maximum possible entropy for normalization</span>
            <span class="k">if</span> <span class="n">normalization</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
                <span class="n">max_entropy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">entropy</span> <span class="o">/</span> <span class="n">max_entropy</span> <span class="k">if</span> <span class="n">max_entropy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">entropy</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown entropy type: </span><span class="si">{</span><span class="n">entropy_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">entropy</span><span class="p">,</span> <span class="n">norm_entropy</span>
    
    <span class="c1"># Calculate entropy</span>
    <span class="n">entropy</span><span class="p">,</span> <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">calculate_entropy</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">normalization</span><span class="p">)</span>
    
    <span class="c1"># Calculate additional spatial metrics</span>
    <span class="c1"># 1. Moran&#39;s I (spatial autocorrelation)</span>
    <span class="n">moran_i</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># 2. Spatial heterogeneity (coefficient of variation)</span>
    <span class="n">cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    
    <span class="c1"># 3. Occupancy (proportion of occupied quadrats)</span>
    <span class="n">occupancy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    
    <span class="c1"># 4. Spatial information (mutual information between x and y coordinates)</span>
    <span class="c1"># This measures how much knowing a cell&#39;s x position tells you about its y position</span>
    <span class="n">spatial_info</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Create 2D histogram for x and y coordinates</span>
        <span class="n">x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">x_grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">y_grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Calculate marginal probabilities</span>
        <span class="n">p_x</span> <span class="o">=</span> <span class="n">x_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_hist</span><span class="p">)</span>
        <span class="n">p_y</span> <span class="o">=</span> <span class="n">y_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_hist</span><span class="p">)</span>
        
        <span class="c1"># Calculate joint probabilities</span>
        <span class="n">p_xy</span> <span class="o">=</span> <span class="n">quadrat_counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">quadrat_counts</span><span class="p">)</span>
        
        <span class="c1"># Calculate mutual information</span>
        <span class="n">spatial_info</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_x</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_y</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">p_xy</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p_y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">spatial_info</span> <span class="o">+=</span> <span class="n">p_xy</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_xy</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">p_y</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">spatial_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error calculating spatial information: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate bootstrap confidence interval if requested</span>
    <span class="n">bootstrap_results</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">bootstrap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate entropy for a bootstrap sample</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">bootstrap_entropy</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">normalization</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Resample points with replacement</span>
            <span class="n">bootstrap_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bootstrap_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">bootstrap_sample</span><span class="p">]</span>
            
            <span class="c1"># Count cells in each quadrat for this bootstrap sample</span>
            <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">y_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># Create a 2D histogram of cell counts per quadrat</span>
            <span class="n">bootstrap_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bootstrap_coords</span><span class="p">)):</span>
                <span class="n">x_idx</span> <span class="o">=</span> <span class="n">x_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">y_idx</span> <span class="o">=</span> <span class="n">y_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">):</span>
                    <span class="n">bootstrap_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Flatten the array for calculations</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">bootstrap_counts</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            
            <span class="c1"># Calculate total number of cells</span>
            <span class="n">total_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Calculate probability for each quadrat (cell proportion)</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">total_cells</span>
            
            <span class="c1"># Remove quadrats with zero counts</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="n">probs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Calculate entropy</span>
            <span class="n">entropy</span><span class="p">,</span> <span class="n">norm_entropy</span> <span class="o">=</span> <span class="n">calculate_entropy</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">normalization</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">entropy</span><span class="p">,</span> <span class="n">norm_entropy</span>
        
        <span class="c1"># Run bootstrap iterations in parallel</span>
        <span class="n">bootstrap_results_raw</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">bootstrap_entropy</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">normalization</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Bootstrap iterations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract raw and normalized entropy values</span>
        <span class="n">bootstrap_entropies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">bootstrap_results_raw</span><span class="p">])</span>
        <span class="n">bootstrap_norm_entropies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">bootstrap_results_raw</span><span class="p">])</span>
        
        <span class="c1"># Calculate confidence intervals</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># 95% confidence interval</span>
        <span class="n">entropy_ci</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">bootstrap_entropies</span><span class="p">,</span> <span class="p">[</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">norm_entropy_ci</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">bootstrap_norm_entropies</span><span class="p">,</span> <span class="p">[</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>
        
        <span class="n">bootstrap_results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;entropy_mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bootstrap_entropies</span><span class="p">),</span>
            <span class="s1">&#39;entropy_std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">bootstrap_entropies</span><span class="p">),</span>
            <span class="s1">&#39;entropy_ci&#39;</span><span class="p">:</span> <span class="n">entropy_ci</span><span class="p">,</span>
            <span class="s1">&#39;norm_entropy_mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bootstrap_norm_entropies</span><span class="p">),</span>
            <span class="s1">&#39;norm_entropy_std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">bootstrap_norm_entropies</span><span class="p">),</span>
            <span class="s1">&#39;norm_entropy_ci&#39;</span><span class="p">:</span> <span class="n">norm_entropy_ci</span>
        <span class="p">}</span>
    
    <span class="c1"># Generate a qualitative interpretation</span>
    <span class="k">if</span> <span class="n">norm_entropy</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">:</span>
        <span class="n">interpretation</span> <span class="o">=</span> <span class="s2">&quot;Highly ordered spatial pattern&quot;</span>
    <span class="k">elif</span> <span class="n">norm_entropy</span> <span class="o">&lt;</span> <span class="mf">0.7</span><span class="p">:</span>
        <span class="n">interpretation</span> <span class="o">=</span> <span class="s2">&quot;Moderately ordered spatial pattern&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interpretation</span> <span class="o">=</span> <span class="s2">&quot;Highly disordered spatial pattern&quot;</span>
    
    <span class="c1"># Compare to a random distribution</span>
    <span class="c1"># For a completely random (Poisson) distribution, the normalized entropy should be close to 1</span>
    <span class="k">if</span> <span class="n">norm_entropy</span> <span class="o">&gt;</span> <span class="mf">0.95</span><span class="p">:</span>
        <span class="n">random_comparison</span> <span class="o">=</span> <span class="s2">&quot;Pattern is consistent with complete spatial randomness&quot;</span>
    <span class="k">elif</span> <span class="n">norm_entropy</span> <span class="o">&gt;</span> <span class="mf">0.8</span><span class="p">:</span>
        <span class="n">random_comparison</span> <span class="o">=</span> <span class="s2">&quot;Pattern is close to spatial randomness&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">random_comparison</span> <span class="o">=</span> <span class="s2">&quot;Pattern shows significant spatial structure (non-random)&quot;</span>
    
    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;entropy&#39;</span><span class="p">:</span> <span class="n">entropy</span><span class="p">,</span>
        <span class="s1">&#39;normalized_entropy&#39;</span><span class="p">:</span> <span class="n">norm_entropy</span><span class="p">,</span>
        <span class="s1">&#39;entropy_type&#39;</span><span class="p">:</span> <span class="n">entropy_type</span><span class="p">,</span>
        <span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="n">interpretation</span><span class="p">,</span>
        <span class="s1">&#39;random_comparison&#39;</span><span class="p">:</span> <span class="n">random_comparison</span><span class="p">,</span>
        <span class="s1">&#39;coefficient_of_variation&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="p">,</span>
        <span class="s1">&#39;occupancy&#39;</span><span class="p">:</span> <span class="n">occupancy</span><span class="p">,</span>
        <span class="s1">&#39;spatial_information&#39;</span><span class="p">:</span> <span class="n">spatial_info</span><span class="p">,</span>
        <span class="s1">&#39;grid_size&#39;</span><span class="p">:</span> <span class="n">grid_size</span><span class="p">,</span>
        <span class="s1">&#39;num_quadrats&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">),</span>
        <span class="s1">&#39;num_occupied_quadrats&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
        <span class="s1">&#39;bootstrap_results&#39;</span><span class="p">:</span> <span class="n">bootstrap_results</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="calculate_hotspot_analysis">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_hotspot_analysis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_hotspot_analysis</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="p">,</span> 
                              <span class="n">p_value_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Getis-Ord Gi* statistic to identify statistically significant spatial hot spots and cold spots.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        attribute_name: Name of the attribute/column in adata.obs to analyze for clustering</span>
<span class="sd">        distance_threshold: Maximum distance (in pixels) to consider neighbors</span>
<span class="sd">        p_value_threshold: Significance threshold for hot/cold spots (default: 0.05)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        permutations: Number of random permutations for significance testing</span>
<span class="sd">        n_jobs: Number of parallel jobs (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with Gi* statistics and hot/cold spot classifications</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get the attribute values from AnnData object</span>
    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping cell IDs to attribute values</span>
    <span class="n">cell_to_attr</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add attribute values to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_attr</span><span class="p">)</span>
    
    <span class="c1"># Drop cells with missing attribute values</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">])</span>
    
    <span class="c1"># Check if attribute is numeric</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; must be numeric for hotspot analysis&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates and attribute values</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Calculate distance matrix</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Create spatial weights matrix (binary weights based on distance threshold)</span>
    <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
    <span class="n">weights_matrix</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">weights_matrix</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Exclude self-connections</span>
    
    <span class="c1"># Row-normalize the weights matrix</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Avoid division by zero</span>
    <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">weights_matrix</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    
    <span class="c1"># Calculate global mean and standard deviation</span>
    <span class="n">global_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">global_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    
    <span class="c1"># Function to calculate Gi* statistic for a single cell</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_gi_star</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">global_mean</span><span class="p">,</span> <span class="n">global_std</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># Get weights for this cell&#39;s neighbors</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Calculate weighted sum</span>
        <span class="n">weighted_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># Calculate sum of weights</span>
        <span class="n">sum_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        
        <span class="c1"># Calculate Gi* statistic</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">weighted_sum</span> <span class="o">-</span> <span class="n">global_mean</span> <span class="o">*</span> <span class="n">sum_weights</span>
        
        <span class="c1"># Calculate denominator</span>
        <span class="n">denominator_term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">denominator_term2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">global_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">denominator_term1</span> <span class="o">-</span> <span class="n">denominator_term2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Handle division by zero</span>
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="c1"># Calculate Gi* statistic</span>
        <span class="n">gi_star</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
        
        <span class="k">return</span> <span class="n">gi_star</span>
    
    <span class="c1"># Calculate Gi* statistic for each cell</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">gi_star_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">calculate_gi_star</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">global_mean</span><span class="p">,</span> <span class="n">global_std</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">])</span>
    
    <span class="c1"># Calculate p-values for each Gi* statistic</span>
    <span class="c1"># Under the null hypothesis, Gi* follows a standard normal distribution</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gi_star_values</span><span class="p">)))</span>  <span class="c1"># Two-tailed test</span>
    
    <span class="c1"># Determine if each cell is a hot spot or cold spot</span>
    <span class="n">hot_spots</span> <span class="o">=</span> <span class="p">(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="n">p_value_threshold</span><span class="p">)</span>
    <span class="n">cold_spots</span> <span class="o">=</span> <span class="p">(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="n">p_value_threshold</span><span class="p">)</span>
    <span class="n">not_significant</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">hot_spots</span> <span class="o">|</span> <span class="n">cold_spots</span><span class="p">)</span>
    
    <span class="c1"># Calculate statistical significance level</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">significance</span><span class="p">[</span><span class="n">not_significant</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Not Significant&#39;</span>
    
    <span class="c1"># Hot spots at different significance levels</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 90%&#39;</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 95%&#39;</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 99%&#39;</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 99.9%&#39;</span>
    
    <span class="c1"># Cold spots at different significance levels</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 90%&#39;</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 95%&#39;</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 99%&#39;</span>
    <span class="n">significance</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 99.9%&#39;</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell_ids</span><span class="p">,</span>
        <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="s1">&#39;attribute&#39;</span><span class="p">:</span> <span class="n">values</span><span class="p">,</span>
        <span class="s1">&#39;gi_star&#39;</span><span class="p">:</span> <span class="n">gi_star_values</span><span class="p">,</span>
        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_values</span><span class="p">,</span>
        <span class="s1">&#39;significance&#39;</span><span class="p">:</span> <span class="n">significance</span><span class="p">,</span>
        <span class="s1">&#39;is_hot_spot&#39;</span><span class="p">:</span> <span class="n">hot_spots</span><span class="p">,</span>
        <span class="s1">&#39;is_cold_spot&#39;</span><span class="p">:</span> <span class="n">cold_spots</span>
    <span class="p">})</span>
    
    <span class="c1"># Optional: Calculate Monte Carlo based p-values using permutation test</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate Gi* statistics for a random permutation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_permutation</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Randomly permute the attribute values</span>
            <span class="n">shuffled_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            
            <span class="c1"># Calculate global mean and standard deviation for shuffled values</span>
            <span class="n">shuffled_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shuffled_values</span><span class="p">)</span>
            <span class="n">shuffled_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">shuffled_values</span><span class="p">)</span>
            
            <span class="c1"># Calculate Gi* for each location</span>
            <span class="n">gi_stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="c1"># Get weights for this cell&#39;s neighbors</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Calculate weighted sum</span>
                <span class="n">weighted_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">shuffled_values</span><span class="p">)</span>
                
                <span class="c1"># Calculate sum of weights</span>
                <span class="n">sum_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
                
                <span class="c1"># Calculate Gi* statistic</span>
                <span class="n">numerator</span> <span class="o">=</span> <span class="n">weighted_sum</span> <span class="o">-</span> <span class="n">shuffled_mean</span> <span class="o">*</span> <span class="n">sum_weights</span>
                
                <span class="c1"># Calculate denominator</span>
                <span class="n">denominator_term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">denominator_term2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="n">shuffled_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">denominator_term1</span> <span class="o">-</span> <span class="n">denominator_term2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Handle division by zero</span>
                <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">gi_stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gi_stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
            
            <span class="k">return</span> <span class="n">gi_stars</span>
        
        <span class="c1"># Run permutations in parallel</span>
        <span class="n">permutation_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_permutation</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">n</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo permutations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Combine permutation results</span>
        <span class="n">permutation_gi_stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permutation_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate empirical p-values</span>
        <span class="n">p_values_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">observed_gi</span> <span class="o">=</span> <span class="n">gi_star_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">observed_gi</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># For positive Gi* (hot spots), count how many permutations have Gi* &gt;= observed</span>
                <span class="n">p_values_mc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">permutation_gi_stars</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">observed_gi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For negative Gi* (cold spots), count how many permutations have Gi* &lt;= observed</span>
                <span class="n">p_values_mc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">permutation_gi_stars</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">observed_gi</span><span class="p">)</span>
        
        <span class="c1"># Update result DataFrame with Monte Carlo p-values</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;p_value_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_values_mc</span>
        
        <span class="c1"># Update significance classifications based on Monte Carlo p-values</span>
        <span class="n">significance_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;Not Significant&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        
        <span class="c1"># Hot spots at different significance levels</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 90%&#39;</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 95%&#39;</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 99%&#39;</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Hot Spot 99.9%&#39;</span>
        
        <span class="c1"># Cold spots at different significance levels</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 90%&#39;</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 95%&#39;</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 99%&#39;</span>
        <span class="n">significance_mc</span><span class="p">[(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;Cold Spot 99.9%&#39;</span>
        
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;significance_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">significance_mc</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_hot_spot_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gi_star_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="n">p_value_threshold</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_cold_spot_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gi_star_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_values_mc</span> <span class="o">&lt;</span> <span class="n">p_value_threshold</span><span class="p">)</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x_col</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y_col</span><span class="p">,</span>
            <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;significance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;color_map&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;Not Significant&#39;</span><span class="p">:</span> <span class="s1">&#39;#BBBBBB&#39;</span><span class="p">,</span>  <span class="c1"># Grey</span>
                <span class="s1">&#39;Hot Spot 90%&#39;</span><span class="p">:</span> <span class="s1">&#39;#FFDC73&#39;</span><span class="p">,</span>     <span class="c1"># Light yellow</span>
                <span class="s1">&#39;Hot Spot 95%&#39;</span><span class="p">:</span> <span class="s1">&#39;#FFA319&#39;</span><span class="p">,</span>     <span class="c1"># Orange</span>
                <span class="s1">&#39;Hot Spot 99%&#39;</span><span class="p">:</span> <span class="s1">&#39;#FF5E00&#39;</span><span class="p">,</span>     <span class="c1"># Dark orange</span>
                <span class="s1">&#39;Hot Spot 99.9%&#39;</span><span class="p">:</span> <span class="s1">&#39;#FF0000&#39;</span><span class="p">,</span>   <span class="c1"># Red</span>
                <span class="s1">&#39;Cold Spot 90%&#39;</span><span class="p">:</span> <span class="s1">&#39;#B3DBFF&#39;</span><span class="p">,</span>    <span class="c1"># Light blue</span>
                <span class="s1">&#39;Cold Spot 95%&#39;</span><span class="p">:</span> <span class="s1">&#39;#73B2FF&#39;</span><span class="p">,</span>    <span class="c1"># Blue</span>
                <span class="s1">&#39;Cold Spot 99%&#39;</span><span class="p">:</span> <span class="s1">&#39;#1975FF&#39;</span><span class="p">,</span>    <span class="c1"># Dark blue</span>
                <span class="s1">&#39;Cold Spot 99.9%&#39;</span><span class="p">:</span> <span class="s1">&#39;#0039C6&#39;</span>   <span class="c1"># Very dark blue</span>
            <span class="p">},</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Hot Spot Analysis of </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Distance threshold: </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s1"> pixels&#39;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_spatial_autocorrelation">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_autocorrelation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_spatial_autocorrelation</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">k_nearest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate spatial autocorrelation using Moran&#39;s I statistic.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        attribute_name: Name of the attribute/column in adata.obs to analyze</span>
<span class="sd">        distance_threshold: Maximum distance (in pixels) to consider neighbors (None if using k_nearest)</span>
<span class="sd">        k_nearest: Number of nearest neighbors to use (None if using distance_threshold)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        local: Whether to calculate Local Moran&#39;s I (True) or Global Moran&#39;s I (False)</span>
<span class="sd">        permutations: Number of random permutations for significance testing</span>
<span class="sd">        n_jobs: Number of parallel jobs (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Global Moran&#39;s I result or DataFrame with Local Moran&#39;s I values and quadrant classifications</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    
    <span class="c1"># Check if either distance_threshold or k_nearest is provided</span>
    <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">k_nearest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either distance_threshold or k_nearest must be provided&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">k_nearest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of distance_threshold or k_nearest should be provided&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get the attribute values from AnnData object</span>
    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping cell IDs to attribute values</span>
    <span class="n">cell_to_attr</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add attribute values to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_attr</span><span class="p">)</span>
    
    <span class="c1"># Drop cells with missing attribute values</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">])</span>
    
    <span class="c1"># Check if attribute is numeric</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; must be numeric for spatial autocorrelation&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates, attribute values, and cell IDs</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Standardize values for easier interpretation</span>
    <span class="n">values_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    
    <span class="c1"># Calculate distance matrix</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Create spatial weights matrix</span>
    <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Binary weights based on distance threshold</span>
        <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        <span class="n">weights_matrix</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">weights_matrix</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Exclude self-connections</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># K-nearest neighbors</span>
        <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="c1"># Get indices of k nearest neighbors</span>
            <span class="n">nearest_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">1</span><span class="p">:</span><span class="n">k_nearest</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Skip self (index 0)</span>
            <span class="n">weights_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">nearest_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># Row-normalize the weights matrix</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Avoid division by zero</span>
    <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">weights_matrix</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    
    <span class="c1"># Calculate spatial lag (weighted average of neighboring values)</span>
    <span class="n">spatial_lag</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">values_std</span><span class="p">)</span>
    
    <span class="c1"># Calculate Global Moran&#39;s I</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_std</span><span class="p">)</span>
    <span class="n">sum_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">)</span>
    
    <span class="c1"># Calculate the numerator (cross-product of centered values)</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">numerator</span> <span class="o">+=</span> <span class="n">weights_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">values_std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">values_std</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    
    <span class="c1"># Calculate the denominator (sum of squared deviations)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">values_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Calculate Moran&#39;s I</span>
    <span class="n">moran_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">sum_weights</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span>
    
    <span class="c1"># Calculate expected value of Moran&#39;s I under the null hypothesis</span>
    <span class="n">expected_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Calculate variance of Moran&#39;s I under the null hypothesis</span>
    <span class="c1"># This is a simplified formula; the exact formula is more complex</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">weights_matrix</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="n">var_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">s2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">sum_weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sum_weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Calculate z-score</span>
    <span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">moran_i</span> <span class="o">-</span> <span class="n">expected_i</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_i</span><span class="p">)</span>
    
    <span class="c1"># Calculate p-value</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z_score</span><span class="p">)))</span>  <span class="c1"># Two-tailed test</span>
    
    <span class="c1"># Determine if spatial pattern is clustered, random, or dispersed</span>
    <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">moran_i</span> <span class="o">&gt;</span> <span class="n">expected_i</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Clustered&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Dispersed&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
    
    <span class="c1"># Calculate p-value using Monte Carlo permutation</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate Moran&#39;s I for a random permutation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_permutation</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">values_std</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sum_weights</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Randomly permute the attribute values</span>
            <span class="n">shuffled_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">values_std</span><span class="p">)</span>
            
            <span class="c1"># Calculate the numerator for shuffled values</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">numerator</span> <span class="o">+=</span> <span class="n">weights_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">shuffled_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">shuffled_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            
            <span class="c1"># Calculate the denominator for shuffled values</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">shuffled_values</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Calculate Moran&#39;s I for shuffled values</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">sum_weights</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span>
        
        <span class="c1"># Run permutations in parallel</span>
        <span class="n">permutation_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_permutation</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">values_std</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sum_weights</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo permutations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Calculate p-value based on permutation distribution</span>
        <span class="k">if</span> <span class="n">moran_i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># For positive Moran&#39;s I, count how many permutations have I &gt;= observed</span>
            <span class="n">p_value_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permutation_results</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">moran_i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For negative Moran&#39;s I, count how many permutations have I &lt;= observed</span>
            <span class="n">p_value_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permutation_results</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">moran_i</span><span class="p">)</span>
        
        <span class="c1"># Update pattern classification based on Monte Carlo p-value</span>
        <span class="k">if</span> <span class="n">p_value_mc</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">moran_i</span> <span class="o">&gt;</span> <span class="n">expected_i</span><span class="p">:</span>
                <span class="n">pattern_mc</span> <span class="o">=</span> <span class="s2">&quot;Clustered&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pattern_mc</span> <span class="o">=</span> <span class="s2">&quot;Dispersed&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern_mc</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_value_mc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pattern_mc</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># If only interested in global Moran&#39;s I, return the result</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">local</span><span class="p">:</span>
        <span class="n">global_result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;moran_i&#39;</span><span class="p">:</span> <span class="n">moran_i</span><span class="p">,</span>
            <span class="s1">&#39;expected_i&#39;</span><span class="p">:</span> <span class="n">expected_i</span><span class="p">,</span>
            <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">var_i</span><span class="p">,</span>
            <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="n">z_score</span><span class="p">,</span>
            <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
            <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="n">pattern</span><span class="p">,</span>
            <span class="s1">&#39;p_value_mc&#39;</span><span class="p">:</span> <span class="n">p_value_mc</span><span class="p">,</span>
            <span class="s1">&#39;pattern_mc&#39;</span><span class="p">:</span> <span class="n">pattern_mc</span><span class="p">,</span>
            <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
            <span class="s1">&#39;attribute&#39;</span><span class="p">:</span> <span class="n">attribute_name</span><span class="p">,</span>
            <span class="s1">&#39;distance_threshold&#39;</span><span class="p">:</span> <span class="n">distance_threshold</span><span class="p">,</span>
            <span class="s1">&#39;k_nearest&#39;</span><span class="p">:</span> <span class="n">k_nearest</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">global_result</span>
    
    <span class="c1"># If local Moran&#39;s I is requested, calculate LISA (Local Indicators of Spatial Association)</span>
    <span class="n">local_moran_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Calculate Local Moran&#39;s I for each cell</span>
        <span class="n">local_moran_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">values_std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">spatial_lag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">sum_weights</span>
    
    <span class="c1"># Calculate expected value of Local Moran&#39;s I under the null hypothesis</span>
    <span class="n">local_expected_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Calculate standardized Local Moran&#39;s I (z-scores)</span>
    <span class="c1"># This is a simplification; exact calculation of variance for Local Moran&#39;s I is complex</span>
    <span class="n">local_z_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_moran_i</span> <span class="o">-</span> <span class="n">local_expected_i</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_i</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    
    <span class="c1"># Calculate p-values for Local Moran&#39;s I</span>
    <span class="n">local_p_values</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">local_z_scores</span><span class="p">)))</span>  <span class="c1"># Two-tailed test</span>
    
    <span class="c1"># Calculate quadrant for each cell (High-High, Low-Low, High-Low, Low-High)</span>
    <span class="c1"># These correspond to:</span>
    <span class="c1"># HH: High values surrounded by high values (positive spatial autocorrelation)</span>
    <span class="c1"># LL: Low values surrounded by low values (positive spatial autocorrelation)</span>
    <span class="c1"># HL: High values surrounded by low values (negative spatial autocorrelation)</span>
    <span class="c1"># LH: Low values surrounded by high values (negative spatial autocorrelation)</span>
    <span class="n">quadrants</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values_std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">spatial_lag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">quadrants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;High-High&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">values_std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">spatial_lag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">quadrants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Low-Low&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">values_std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">spatial_lag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">quadrants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;High-Low&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># values_std[i] &lt; 0 and spatial_lag[i] &gt;= 0</span>
            <span class="n">quadrants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Low-High&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate Local Moran&#39;s I p-values using Monte Carlo permutation</span>
    <span class="n">local_p_values_mc</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Array to store permutation results for each location</span>
        <span class="n">permutation_local_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">permutations</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="c1"># Function to calculate Local Moran&#39;s I for a random permutation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_local_permutation</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">values_std</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sum_weights</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Randomly permute the attribute values</span>
            <span class="n">shuffled_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">values_std</span><span class="p">)</span>
            
            <span class="c1"># Calculate spatial lag for shuffled values</span>
            <span class="n">shuffled_lag</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">shuffled_values</span><span class="p">)</span>
            
            <span class="c1"># Calculate Local Moran&#39;s I for each cell</span>
            <span class="n">local_i</span> <span class="o">=</span> <span class="n">shuffled_values</span> <span class="o">*</span> <span class="n">shuffled_lag</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">sum_weights</span>
            
            <span class="k">return</span> <span class="n">local_i</span>
        
        <span class="c1"># Run permutations in parallel</span>
        <span class="n">permutation_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_local_permutation</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">values_std</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sum_weights</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo permutations for Local Moran&#39;s I&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Stack results for easier processing</span>
        <span class="n">permutation_local_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">permutation_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate p-values based on permutation distribution</span>
        <span class="n">local_p_values_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">local_moran_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># For positive Local Moran&#39;s I, count how many permutations have I &gt;= observed</span>
                <span class="n">local_p_values_mc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">permutation_local_i</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">local_moran_i</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For negative Local Moran&#39;s I, count how many permutations have I &lt;= observed</span>
                <span class="n">local_p_values_mc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">permutation_local_i</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">local_moran_i</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="c1"># Create result DataFrame for Local Moran&#39;s I</span>
    <span class="n">local_result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell_ids</span><span class="p">,</span>
        <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="s1">&#39;attribute&#39;</span><span class="p">:</span> <span class="n">values</span><span class="p">,</span>
        <span class="s1">&#39;attribute_std&#39;</span><span class="p">:</span> <span class="n">values_std</span><span class="p">,</span>
        <span class="s1">&#39;spatial_lag&#39;</span><span class="p">:</span> <span class="n">spatial_lag</span><span class="p">,</span>
        <span class="s1">&#39;local_moran_i&#39;</span><span class="p">:</span> <span class="n">local_moran_i</span><span class="p">,</span>
        <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="n">local_z_scores</span><span class="p">,</span>
        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">local_p_values</span><span class="p">,</span>
        <span class="s1">&#39;quadrant&#39;</span><span class="p">:</span> <span class="n">quadrants</span><span class="p">,</span>
        <span class="s1">&#39;is_significant&#39;</span><span class="p">:</span> <span class="n">local_p_values</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
    <span class="p">})</span>
    
    <span class="k">if</span> <span class="n">local_p_values_mc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">local_result</span><span class="p">[</span><span class="s1">&#39;p_value_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_p_values_mc</span>
        <span class="n">local_result</span><span class="p">[</span><span class="s1">&#39;is_significant_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_p_values_mc</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Define color map for quadrants</span>
        <span class="n">quadrant_colors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;High-High&#39;</span><span class="p">:</span> <span class="s1">&#39;#FF0000&#39;</span><span class="p">,</span>    <span class="c1"># Red</span>
            <span class="s1">&#39;Low-Low&#39;</span><span class="p">:</span> <span class="s1">&#39;#0000FF&#39;</span><span class="p">,</span>      <span class="c1"># Blue</span>
            <span class="s1">&#39;High-Low&#39;</span><span class="p">:</span> <span class="s1">&#39;#FFA500&#39;</span><span class="p">,</span>     <span class="c1"># Orange</span>
            <span class="s1">&#39;Low-High&#39;</span><span class="p">:</span> <span class="s1">&#39;#00FFFF&#39;</span><span class="p">,</span>     <span class="c1"># Cyan</span>
            <span class="s1">&#39;Not Significant&#39;</span><span class="p">:</span> <span class="s1">&#39;#BBBBBB&#39;</span>  <span class="c1"># Grey</span>
        <span class="p">}</span>
        
        <span class="c1"># Create plot configuration</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x_col</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y_col</span><span class="p">,</span>
            <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;plot_category&#39;</span><span class="p">,</span>
            <span class="s1">&#39;color_map&#39;</span><span class="p">:</span> <span class="n">quadrant_colors</span><span class="p">,</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Local Moran</span><span class="se">\&#39;</span><span class="s1">s I for </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Distance threshold: </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s1"> pixels&#39;</span> <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;K-nearest: </span><span class="si">{</span><span class="n">k_nearest</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">}</span>
        
        <span class="c1"># Add a column for plotting (only significant quadrants get colored)</span>
        <span class="n">local_result</span><span class="p">[</span><span class="s1">&#39;plot_category&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Not Significant&#39;</span>
        
        <span class="c1"># Use Monte Carlo p-values if available</span>
        <span class="k">if</span> <span class="s1">&#39;is_significant_mc&#39;</span> <span class="ow">in</span> <span class="n">local_result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">significant_mask</span> <span class="o">=</span> <span class="n">local_result</span><span class="p">[</span><span class="s1">&#39;is_significant_mc&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">significant_mask</span> <span class="o">=</span> <span class="n">local_result</span><span class="p">[</span><span class="s1">&#39;is_significant&#39;</span><span class="p">]</span>
            
        <span class="n">local_result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">significant_mask</span><span class="p">,</span> <span class="s1">&#39;plot_category&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">significant_mask</span><span class="p">,</span> <span class="s1">&#39;quadrant&#39;</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">local_result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">local_result</span></div>


<div class="viewcode-block" id="calculate_kernel_density">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_kernel_density">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_kernel_density</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                            <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">density_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Kernel Density Estimation to visualize the spatial density of cells.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        bandwidth: Bandwidth for the kernel density estimator (None for automatic selection)</span>
<span class="sd">        grid_size: Number of grid points in each dimension for density estimation</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        kernel: Type of kernel to use (&#39;gaussian&#39;, &#39;epanechnikov&#39;, &#39;tophat&#39;, etc.)</span>
<span class="sd">        normalize: Whether to normalize the density to sum to 1</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        density_threshold: Optional threshold to identify high-density regions (quantile between 0 and 1)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing KDE results, including density grid, coordinates, and metrics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">KernelDensity</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">DBSCAN</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">label</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">skimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">measure</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Determine the boundaries of the study area</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Add a small buffer to the boundaries</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">),</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.05</span>
    <span class="n">x_min</span> <span class="o">-=</span> <span class="n">buffer</span>
    <span class="n">y_min</span> <span class="o">-=</span> <span class="n">buffer</span>
    <span class="n">x_max</span> <span class="o">+=</span> <span class="n">buffer</span>
    <span class="n">y_max</span> <span class="o">+=</span> <span class="n">buffer</span>
    
    <span class="c1"># Create a grid for density estimation</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
    <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">)</span>
    <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># Normalize coordinates for KDE</span>
    <span class="n">x_range</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
    <span class="n">y_range</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
    <span class="n">coords_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">coords_norm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_range</span>
    <span class="n">coords_norm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_range</span>
    
    <span class="c1"># Scale grid points similarly</span>
    <span class="n">grid_points_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>
    <span class="n">grid_points_norm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_range</span>
    <span class="n">grid_points_norm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_range</span>
    
    <span class="c1"># Determine bandwidth if not provided</span>
    <span class="k">if</span> <span class="n">bandwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Scott&#39;s rule of thumb for bandwidth selection</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">1.06</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">coords_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Scale bandwidth to the normalized coordinates</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="p">)</span>
    
    <span class="c1"># Perform KDE</span>
    <span class="n">kde</span> <span class="o">=</span> <span class="n">KernelDensity</span><span class="p">(</span><span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="n">kde</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coords_norm</span><span class="p">)</span>
    
    <span class="c1"># Calculate log density on the grid</span>
    <span class="n">log_density</span> <span class="o">=</span> <span class="n">kde</span><span class="o">.</span><span class="n">score_samples</span><span class="p">(</span><span class="n">grid_points_norm</span><span class="p">)</span>
    
    <span class="c1"># Convert back to density</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_density</span><span class="p">)</span>
    
    <span class="c1"># Normalize if requested</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">density</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
    
    <span class="c1"># Reshape to grid</span>
    <span class="n">density_grid</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># Calculate high-density regions if threshold is provided</span>
    <span class="n">hotspots</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">density_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Apply threshold to identify high-density regions</span>
        <span class="n">threshold_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="n">density_threshold</span><span class="p">)</span>
        <span class="n">binary_map</span> <span class="o">=</span> <span class="n">density_grid</span> <span class="o">&gt;</span> <span class="n">threshold_value</span>
        
        <span class="c1"># Label connected components</span>
        <span class="n">labeled_map</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">binary_map</span><span class="p">)</span>
        
        <span class="c1"># Extract properties of each hotspot</span>
        <span class="k">if</span> <span class="n">num_features</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Find contours</span>
            <span class="n">contours</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">find_contours</span><span class="p">(</span><span class="n">density_grid</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>
            
            <span class="c1"># Initialize list to store hotspot data</span>
            <span class="n">hotspots</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># Calculate properties for each labeled region</span>
            <span class="k">for</span> <span class="n">region_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">region_mask</span> <span class="o">=</span> <span class="n">labeled_map</span> <span class="o">==</span> <span class="n">region_id</span>
                
                <span class="c1"># Calculate region properties</span>
                <span class="n">y_indices</span><span class="p">,</span> <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">region_mask</span><span class="p">)</span>
                <span class="n">region_density</span> <span class="o">=</span> <span class="n">density_grid</span><span class="p">[</span><span class="n">region_mask</span><span class="p">]</span>
                
                <span class="c1"># Map indices back to original coordinates</span>
                <span class="n">region_x</span> <span class="o">=</span> <span class="n">x_grid</span><span class="p">[</span><span class="n">x_indices</span><span class="p">]</span>
                <span class="n">region_y</span> <span class="o">=</span> <span class="n">y_grid</span><span class="p">[</span><span class="n">y_indices</span><span class="p">]</span>
                
                <span class="c1"># Find cells within the region</span>
                <span class="n">cells_in_region</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">x_min</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x_max</span> <span class="ow">and</span> <span class="n">y_min</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y_max</span><span class="p">):</span>
                        <span class="c1"># Find closest grid point</span>
                        <span class="n">x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_grid</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span>
                        <span class="n">y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_grid</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
                        
                        <span class="c1"># Check if this point is in the region</span>
                        <span class="k">if</span> <span class="n">region_mask</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]:</span>
                            <span class="n">cells_in_region</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cells</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;cell&#39;</span><span class="p">])</span>
                
                <span class="c1"># Find contour for this region</span>
                <span class="n">region_contour</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
                    <span class="c1"># Convert contour coordinates to grid indices</span>
                    <span class="n">contour_x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_grid</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">contour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span>
                    <span class="n">contour_y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_grid</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">contour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]])</span>
                    
                    <span class="c1"># Check if contour belongs to this region</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">region_mask</span><span class="p">[</span><span class="n">contour_y_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">contour_x_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                        <span class="c1"># Convert contour to original coordinates</span>
                        <span class="n">region_contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                            <span class="n">x_grid</span><span class="p">[</span><span class="n">contour_x_idx</span><span class="p">],</span>
                            <span class="n">y_grid</span><span class="p">[</span><span class="n">contour_y_idx</span><span class="p">]</span>
                        <span class="p">))</span>
                        <span class="k">break</span>
                
                <span class="c1"># Store region data</span>
                <span class="n">hotspots</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">region_id</span><span class="p">,</span>
                    <span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="n">region_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="s1">&#39;mean_density&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">region_density</span><span class="p">),</span>
                    <span class="s1">&#39;max_density&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">region_density</span><span class="p">),</span>
                    <span class="s1">&#39;centroid_x&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">region_x</span><span class="p">),</span>
                    <span class="s1">&#39;centroid_y&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">region_y</span><span class="p">),</span>
                    <span class="s1">&#39;num_cells&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_in_region</span><span class="p">),</span>
                    <span class="s1">&#39;cell_ids&#39;</span><span class="p">:</span> <span class="n">cells_in_region</span><span class="p">,</span>
                    <span class="s1">&#39;contour&#39;</span><span class="p">:</span> <span class="n">region_contour</span>
                <span class="p">})</span>
    
    <span class="c1"># Calculate density metrics</span>
    <span class="n">min_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">density_grid</span><span class="p">)</span>
    <span class="n">max_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">density_grid</span><span class="p">)</span>
    <span class="n">mean_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">density_grid</span><span class="p">)</span>
    <span class="n">std_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">density_grid</span><span class="p">)</span>
    
    <span class="c1"># Calculate coefficient of variation to measure heterogeneity</span>
    <span class="n">cv</span> <span class="o">=</span> <span class="n">std_density</span> <span class="o">/</span> <span class="n">mean_density</span> <span class="k">if</span> <span class="n">mean_density</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    
    <span class="c1"># Calculate entropy of the density distribution</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">density_grid</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">density_grid</span><span class="p">)</span>
        <span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">entropy</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Create result dictionary</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;density_grid&#39;</span><span class="p">:</span> <span class="n">density_grid</span><span class="p">,</span>
        <span class="s1">&#39;x_grid&#39;</span><span class="p">:</span> <span class="n">x_grid</span><span class="p">,</span>
        <span class="s1">&#39;y_grid&#39;</span><span class="p">:</span> <span class="n">y_grid</span><span class="p">,</span>
        <span class="s1">&#39;bandwidth&#39;</span><span class="p">:</span> <span class="n">bandwidth</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="p">),</span>  <span class="c1"># Convert back to original scale</span>
        <span class="s1">&#39;min_density&#39;</span><span class="p">:</span> <span class="n">min_density</span><span class="p">,</span>
        <span class="s1">&#39;max_density&#39;</span><span class="p">:</span> <span class="n">max_density</span><span class="p">,</span>
        <span class="s1">&#39;mean_density&#39;</span><span class="p">:</span> <span class="n">mean_density</span><span class="p">,</span>
        <span class="s1">&#39;std_density&#39;</span><span class="p">:</span> <span class="n">std_density</span><span class="p">,</span>
        <span class="s1">&#39;coefficient_of_variation&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="p">,</span>
        <span class="s1">&#39;entropy&#39;</span><span class="p">:</span> <span class="n">entropy</span><span class="p">,</span>
        <span class="s1">&#39;cell_coordinates&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">,</span>
        <span class="s1">&#39;grid_size&#39;</span><span class="p">:</span> <span class="n">grid_size</span><span class="p">,</span>
        <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">kernel</span><span class="p">,</span>
        <span class="s1">&#39;hotspots&#39;</span><span class="p">:</span> <span class="n">hotspots</span><span class="p">,</span>
        <span class="s1">&#39;density_threshold&#39;</span><span class="p">:</span> <span class="n">density_threshold</span>
    <span class="p">}</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Define plot configuration</span>
        <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;heatmap&#39;</span><span class="p">,</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">density_grid</span><span class="p">,</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x_grid</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y_grid</span><span class="p">,</span>
            <span class="s1">&#39;colormap&#39;</span><span class="p">:</span> <span class="s1">&#39;viridis&#39;</span><span class="p">,</span>
            <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Kernel Density Estimation&#39;</span><span class="p">,</span>
            <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Bandwidth: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> pixels, Kernel: </span><span class="si">{</span><span class="n">kernel</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="n">x_col</span><span class="p">,</span>
            <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="n">y_col</span><span class="p">,</span>
            <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="n">coords</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Plot points if not too many</span>
            <span class="s1">&#39;contours&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># Add contour lines</span>
            <span class="s1">&#39;hotspots&#39;</span><span class="p">:</span> <span class="n">hotspots</span>  <span class="c1"># Add hotspot contours if available</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_spatial_heterogeneity">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_heterogeneity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_spatial_heterogeneity</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">attribute_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gene_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                   <span class="n">grid_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">method</span><span class="o">=</span><span class="s1">&#39;quadrat&#39;</span><span class="p">,</span> <span class="n">gradient_detection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate spatial heterogeneity index to quantify and characterize spatial variation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        attribute_name: Column name in adata.obs containing attribute values (exclusive with gene_name)</span>
<span class="sd">        gene_name: Gene name to analyze expression heterogeneity (exclusive with attribute_name)</span>
<span class="sd">        grid_size: Size of grid cells in pixels for quadrat analysis (required for &#39;quadrat&#39; method)</span>
<span class="sd">        kernel_bandwidth: Bandwidth for kernel density estimation (required for &#39;kernel&#39; method)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        method: Method for heterogeneity calculation (&#39;quadrat&#39;, &#39;kernel&#39;, &#39;nn&#39;, or &#39;variogram&#39;)</span>
<span class="sd">        gradient_detection: Whether to detect and characterize spatial gradients (True) or not (False)</span>
<span class="sd">        n_jobs: Number of parallel jobs (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing heterogeneity metrics and spatial variation patterns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">KernelDensity</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">skimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">measure</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">filters</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaussian_filter</span>
    
    <span class="c1"># Validate input parameters</span>
    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gene_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of attribute_name or gene_name should be provided&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gene_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either attribute_name or gene_name must be provided&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quadrat&#39;</span> <span class="ow">and</span> <span class="n">grid_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid_size is required for &#39;quadrat&#39; method&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kernel&#39;</span> <span class="ow">and</span> <span class="n">kernel_bandwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kernel_bandwidth is required for &#39;kernel&#39; method&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates and cell IDs</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Check if we have enough cells</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough cells for spatial heterogeneity analysis (need at least 5)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get attribute or gene expression values</span>
    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Attribute is in cell metadata</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">analysis_name</span> <span class="o">=</span> <span class="n">attribute_name</span>
        <span class="k">elif</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Attribute is in AnnData object</span>
            <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">attr_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">])</span>
            <span class="n">analysis_name</span> <span class="o">=</span> <span class="n">attribute_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; not found in cell metadata or adata.obs&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get gene expression values</span>
        <span class="k">if</span> <span class="n">gene_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gene &#39;</span><span class="si">{</span><span class="n">gene_name</span><span class="si">}</span><span class="s2">&#39; not found in the data&quot;</span><span class="p">)</span>
            
        <span class="c1"># Extract gene expression values</span>
        <span class="n">gene_idx</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene_name</span><span class="p">)</span>
        <span class="n">expr_values</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">gene_idx</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1"># Create mapping from cell ID to expression value</span>
        <span class="n">expr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">expr_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">)}</span>
        
        <span class="c1"># Get expression for cells in our filtered set</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">expr_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">])</span>
        <span class="n">analysis_name</span> <span class="o">=</span> <span class="n">gene_name</span>
    
    <span class="c1"># Remove NaN values</span>
    <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">coords_valid</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
    <span class="n">values_valid</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
    <span class="n">cell_ids_valid</span> <span class="o">=</span> <span class="n">cell_ids</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not enough valid values for &#39;</span><span class="si">{</span><span class="n">analysis_name</span><span class="si">}</span><span class="s2">&#39; (need at least 5)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate basic statistics</span>
    <span class="n">value_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
    <span class="n">value_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
    <span class="n">value_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
    <span class="n">value_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
    <span class="n">value_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
    <span class="n">value_cv</span> <span class="o">=</span> <span class="n">value_std</span> <span class="o">/</span> <span class="n">value_mean</span> <span class="k">if</span> <span class="n">value_mean</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Coefficient of variation</span>
    
    <span class="c1"># Calculate global heterogeneity metrics</span>
    <span class="n">global_metrics</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">analysis_name</span><span class="p">,</span>
        <span class="s1">&#39;n_cells&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_valid</span><span class="p">),</span>
        <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">value_min</span><span class="p">,</span>
        <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">value_max</span><span class="p">,</span>
        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">value_mean</span><span class="p">,</span>
        <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="n">value_median</span><span class="p">,</span>
        <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">value_std</span><span class="p">,</span>
        <span class="s1">&#39;cv&#39;</span><span class="p">:</span> <span class="n">value_cv</span><span class="p">,</span>
        <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="n">value_max</span> <span class="o">-</span> <span class="n">value_min</span><span class="p">,</span>
        <span class="s1">&#39;iqr&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">values_valid</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">values_valid</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1"># Calculate spatial heterogeneity using the selected method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quadrat&#39;</span><span class="p">:</span>
        <span class="c1"># Determine the boundaries of the study area</span>
        <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add a small buffer to the boundaries</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">),</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.05</span>
        <span class="n">x_min</span> <span class="o">-=</span> <span class="n">buffer</span>
        <span class="n">y_min</span> <span class="o">-=</span> <span class="n">buffer</span>
        <span class="n">x_max</span> <span class="o">+=</span> <span class="n">buffer</span>
        <span class="n">y_max</span> <span class="o">+=</span> <span class="n">buffer</span>
        
        <span class="c1"># Create grid cells (quadrats)</span>
        <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">+</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        
        <span class="c1"># Count cells in each quadrat and calculate statistics</span>
        <span class="n">quadrat_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">quadrat_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">values_valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># Find which quadrat this cell belongs to</span>
            <span class="n">x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">quadrat_values</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
                <span class="n">quadrat_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Calculate average value in each quadrat</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">quadrat_means</span> <span class="o">=</span> <span class="n">quadrat_values</span> <span class="o">/</span> <span class="n">quadrat_counts</span>
        
        <span class="c1"># Replace NaNs with 0</span>
        <span class="n">quadrat_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_fill</span><span class="p">(</span><span class="n">quadrat_means</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Calculate spatial heterogeneity metrics</span>
        <span class="n">quadrat_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">quadrat_means</span><span class="p">[</span><span class="n">quadrat_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">quadrat_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">quadrat_means</span><span class="p">[</span><span class="n">quadrat_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">quadrat_cv</span> <span class="o">=</span> <span class="n">quadrat_std</span> <span class="o">/</span> <span class="n">quadrat_mean</span> <span class="k">if</span> <span class="n">quadrat_mean</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Calculate variability between quadrats</span>
        <span class="n">variance_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">quadrat_means</span><span class="p">[</span><span class="n">quadrat_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
        
        <span class="c1"># Calculate Moran&#39;s I for quadrats</span>
        <span class="n">quadrat_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quadrat_values_list</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">y_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">quadrat_counts</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Get quadrat center</span>
                    <span class="n">x_center</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_grid</span><span class="p">[</span><span class="n">x_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_grid</span><span class="p">[</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">y_center</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_grid</span><span class="p">[</span><span class="n">y_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_grid</span><span class="p">[</span><span class="n">y_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    
                    <span class="n">quadrat_coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">])</span>
                    <span class="n">quadrat_values_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quadrat_means</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">])</span>
        
        <span class="n">quadrat_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quadrat_coords</span><span class="p">)</span>
        <span class="n">quadrat_values_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quadrat_values_list</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">quadrat_coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Calculate pairwise distances between quadrats</span>
            <span class="n">quadrat_dists</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">quadrat_coords</span><span class="p">))</span>
            
            <span class="c1"># Calculate Moran&#39;s I</span>
            <span class="c1"># Standardize values</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">quadrat_values_list</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">quadrat_values_list</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">quadrat_values_list</span><span class="p">)</span>
            
            <span class="c1"># Define weights (inverse distance)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">quadrat_dists</span><span class="p">)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">quadrat_dists</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">quadrat_dists</span><span class="p">[</span><span class="n">quadrat_dists</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Row-normalize weights</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Calculate Moran&#39;s I</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quadrat_values_list</span><span class="p">)</span>
            <span class="n">zw</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">morans_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">zw</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            
            <span class="c1"># Expected value of Moran&#39;s I under randomization</span>
            <span class="n">expected_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># If Moran&#39;s I is significantly positive, we have clustering</span>
            <span class="n">is_clustered</span> <span class="o">=</span> <span class="n">morans_i</span> <span class="o">&gt;</span> <span class="n">expected_i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">morans_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">expected_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">is_clustered</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1"># Store results</span>
        <span class="n">heterogeneity_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;quadrat&#39;</span><span class="p">,</span>
            <span class="s1">&#39;grid_size&#39;</span><span class="p">:</span> <span class="n">grid_size</span><span class="p">,</span>
            <span class="s1">&#39;n_quadrats&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">quadrat_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s1">&#39;quadrat_mean&#39;</span><span class="p">:</span> <span class="n">quadrat_mean</span><span class="p">,</span>
            <span class="s1">&#39;quadrat_std&#39;</span><span class="p">:</span> <span class="n">quadrat_std</span><span class="p">,</span>
            <span class="s1">&#39;quadrat_cv&#39;</span><span class="p">:</span> <span class="n">quadrat_cv</span><span class="p">,</span>
            <span class="s1">&#39;variance_ratio&#39;</span><span class="p">:</span> <span class="n">variance_ratio</span><span class="p">,</span>
            <span class="s1">&#39;morans_i&#39;</span><span class="p">:</span> <span class="n">morans_i</span><span class="p">,</span>
            <span class="s1">&#39;expected_i&#39;</span><span class="p">:</span> <span class="n">expected_i</span><span class="p">,</span>
            <span class="s1">&#39;is_clustered&#39;</span><span class="p">:</span> <span class="n">is_clustered</span>
        <span class="p">}</span>
        
        <span class="c1"># Prepare grid data for plotting</span>
        <span class="n">grid_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x_grid&#39;</span><span class="p">:</span> <span class="n">x_grid</span><span class="p">,</span>
            <span class="s1">&#39;y_grid&#39;</span><span class="p">:</span> <span class="n">y_grid</span><span class="p">,</span>
            <span class="s1">&#39;quadrat_means&#39;</span><span class="p">:</span> <span class="n">quadrat_means</span><span class="p">,</span>
            <span class="s1">&#39;quadrat_counts&#39;</span><span class="p">:</span> <span class="n">quadrat_counts</span>
        <span class="p">}</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kernel&#39;</span><span class="p">:</span>
        <span class="c1"># Determine the boundaries of the study area</span>
        <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add a small buffer to the boundaries</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">),</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.05</span>
        <span class="n">x_min</span> <span class="o">-=</span> <span class="n">buffer</span>
        <span class="n">y_min</span> <span class="o">-=</span> <span class="n">buffer</span>
        <span class="n">x_max</span> <span class="o">+=</span> <span class="n">buffer</span>
        <span class="n">y_max</span> <span class="o">+=</span> <span class="n">buffer</span>
        
        <span class="c1"># Create a grid for density estimation</span>
        <span class="n">grid_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Adaptive grid size</span>
        <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">)</span>
        <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c1"># Normalize coordinates for KDE</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span>
        <span class="n">coords_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)</span>
        <span class="n">coords_norm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords_valid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_range</span>
        <span class="n">coords_norm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords_valid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_range</span>
        
        <span class="c1"># Scale grid points similarly</span>
        <span class="n">grid_points_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>
        <span class="n">grid_points_norm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_range</span>
        <span class="n">grid_points_norm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_range</span>
        
        <span class="c1"># Use a value-weighted KDE approach</span>
        <span class="c1"># Create a KDE model with the given bandwidth</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">KernelDensity</span><span class="p">(</span><span class="n">bandwidth</span><span class="o">=</span><span class="n">kernel_bandwidth</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="p">),</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span>
        
        <span class="c1"># Weight points by their values</span>
        <span class="c1"># Normalize values to [0, 1]</span>
        <span class="n">normalized_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">values_valid</span> <span class="o">-</span> <span class="n">value_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">value_max</span> <span class="o">-</span> <span class="n">value_min</span><span class="p">)</span> <span class="k">if</span> <span class="n">value_max</span> <span class="o">&gt;</span> <span class="n">value_min</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
        
        <span class="c1"># Fit KDE with value weights</span>
        <span class="n">kde</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coords_norm</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">normalized_values</span><span class="p">)</span>
        
        <span class="c1"># Calculate log density on the grid</span>
        <span class="n">log_density</span> <span class="o">=</span> <span class="n">kde</span><span class="o">.</span><span class="n">score_samples</span><span class="p">(</span><span class="n">grid_points_norm</span><span class="p">)</span>
        
        <span class="c1"># Convert to density</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_density</span><span class="p">)</span>
        
        <span class="c1"># Reshape to grid</span>
        <span class="n">density_grid</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="c1"># Calculate spatial heterogeneity metrics</span>
        <span class="n">kernel_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
        <span class="n">kernel_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
        <span class="n">kernel_cv</span> <span class="o">=</span> <span class="n">kernel_std</span> <span class="o">/</span> <span class="n">kernel_mean</span> <span class="k">if</span> <span class="n">kernel_mean</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Calculate coefficient of spatial variation (ratio of spatial to total variance)</span>
        <span class="n">total_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
        <span class="n">spatial_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
        <span class="n">csv</span> <span class="o">=</span> <span class="n">spatial_variance</span> <span class="o">/</span> <span class="n">total_variance</span> <span class="k">if</span> <span class="n">total_variance</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Store results</span>
        <span class="n">heterogeneity_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;kernel&#39;</span><span class="p">,</span>
            <span class="s1">&#39;bandwidth&#39;</span><span class="p">:</span> <span class="n">kernel_bandwidth</span><span class="p">,</span>
            <span class="s1">&#39;kernel_mean&#39;</span><span class="p">:</span> <span class="n">kernel_mean</span><span class="p">,</span>
            <span class="s1">&#39;kernel_std&#39;</span><span class="p">:</span> <span class="n">kernel_std</span><span class="p">,</span>
            <span class="s1">&#39;kernel_cv&#39;</span><span class="p">:</span> <span class="n">kernel_cv</span><span class="p">,</span>
            <span class="s1">&#39;spatial_variance&#39;</span><span class="p">:</span> <span class="n">spatial_variance</span><span class="p">,</span>
            <span class="s1">&#39;total_variance&#39;</span><span class="p">:</span> <span class="n">total_variance</span><span class="p">,</span>
            <span class="s1">&#39;coef_spatial_variation&#39;</span><span class="p">:</span> <span class="n">csv</span>
        <span class="p">}</span>
        
        <span class="c1"># Prepare grid data for plotting</span>
        <span class="n">grid_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x_grid&#39;</span><span class="p">:</span> <span class="n">x_grid</span><span class="p">,</span>
            <span class="s1">&#39;y_grid&#39;</span><span class="p">:</span> <span class="n">y_grid</span><span class="p">,</span>
            <span class="s1">&#39;density_grid&#39;</span><span class="p">:</span> <span class="n">density_grid</span>
        <span class="p">}</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate nearest neighbor distances</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least 2 valid cells for nearest neighbor analysis&quot;</span><span class="p">)</span>
            
        <span class="c1"># Calculate pairwise distances</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">))</span>
        
        <span class="c1"># For each cell, find nearest neighbor and the difference in values</span>
        <span class="n">nn_diffs</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)):</span>
            <span class="c1"># Get distances to all other cells</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># Find the nearest neighbor (exclude self)</span>
            <span class="n">nn_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dists</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Second smallest (after self)</span>
            <span class="n">nn_dist</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">nn_idx</span><span class="p">]</span>
            
            <span class="c1"># Calculate value difference</span>
            <span class="n">value_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">values_valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">values_valid</span><span class="p">[</span><span class="n">nn_idx</span><span class="p">])</span>
            
            <span class="n">nn_diffs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="n">cell_ids_valid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="s1">&#39;nn_dist&#39;</span><span class="p">:</span> <span class="n">nn_dist</span><span class="p">,</span>
                <span class="s1">&#39;value_diff&#39;</span><span class="p">:</span> <span class="n">value_diff</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">values_valid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="s1">&#39;nn_value&#39;</span><span class="p">:</span> <span class="n">values_valid</span><span class="p">[</span><span class="n">nn_idx</span><span class="p">]</span>
            <span class="p">})</span>
        
        <span class="c1"># Convert to DataFrame</span>
        <span class="n">nn_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">nn_diffs</span><span class="p">)</span>
        
        <span class="c1"># Calculate correlation between distance and value difference</span>
        <span class="n">correlation</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">nn_df</span><span class="p">[</span><span class="s1">&#39;nn_dist&#39;</span><span class="p">],</span> <span class="n">nn_df</span><span class="p">[</span><span class="s1">&#39;value_diff&#39;</span><span class="p">])</span>
        
        <span class="c1"># Calculate spatial heterogeneity metrics</span>
        <span class="n">nn_mean_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nn_df</span><span class="p">[</span><span class="s1">&#39;value_diff&#39;</span><span class="p">])</span>
        <span class="n">nn_std_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">nn_df</span><span class="p">[</span><span class="s1">&#39;value_diff&#39;</span><span class="p">])</span>
        <span class="n">nn_cv_diff</span> <span class="o">=</span> <span class="n">nn_std_diff</span> <span class="o">/</span> <span class="n">nn_mean_diff</span> <span class="k">if</span> <span class="n">nn_mean_diff</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Calculate spatial autocorrelation</span>
        <span class="c1"># Standardize values</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">values_valid</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values_valid</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
        
        <span class="c1"># Create weights matrix based on nearest neighbors</span>
        <span class="n">nn_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)):</span>
            <span class="c1"># Find index of nearest neighbor</span>
            <span class="n">nn_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Second smallest (after self)</span>
            <span class="n">nn_weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">nn_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># Calculate Moran&#39;s I for nearest neighbors</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_valid</span><span class="p">)</span>
        <span class="n">zw</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">morans_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">zw</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="c1"># Expected value of Moran&#39;s I under randomization</span>
        <span class="n">expected_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Calculate Geary&#39;s C for nearest neighbors</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nn_weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">numerator</span> <span class="o">+=</span> <span class="n">nn_weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">geary_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numerator</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">denominator</span><span class="p">)</span>
        
        <span class="c1"># Store results</span>
        <span class="n">heterogeneity_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;nn&#39;</span><span class="p">,</span>
            <span class="s1">&#39;nn_mean_diff&#39;</span><span class="p">:</span> <span class="n">nn_mean_diff</span><span class="p">,</span>
            <span class="s1">&#39;nn_std_diff&#39;</span><span class="p">:</span> <span class="n">nn_std_diff</span><span class="p">,</span>
            <span class="s1">&#39;nn_cv_diff&#39;</span><span class="p">:</span> <span class="n">nn_cv_diff</span><span class="p">,</span>
            <span class="s1">&#39;correlation&#39;</span><span class="p">:</span> <span class="n">correlation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;correlation_pvalue&#39;</span><span class="p">:</span> <span class="n">correlation</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;morans_i&#39;</span><span class="p">:</span> <span class="n">morans_i</span><span class="p">,</span>
            <span class="s1">&#39;expected_i&#39;</span><span class="p">:</span> <span class="n">expected_i</span><span class="p">,</span>
            <span class="s1">&#39;geary_c&#39;</span><span class="p">:</span> <span class="n">geary_c</span><span class="p">,</span>
            <span class="s1">&#39;expected_c&#39;</span><span class="p">:</span> <span class="mf">1.0</span>
        <span class="p">}</span>
        
        <span class="c1"># Prepare nearest neighbor data for plotting</span>
        <span class="n">grid_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;nn_df&#39;</span><span class="p">:</span> <span class="n">nn_df</span><span class="p">,</span>
            <span class="s1">&#39;coords&#39;</span><span class="p">:</span> <span class="n">coords_valid</span>
        <span class="p">}</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;variogram&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate experimental variogram</span>
        <span class="c1"># Define distance bins</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">distance_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">,</span> <span class="n">n_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">distance_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">distance_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Calculate pairwise distances and value differences</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">))</span>
        
        <span class="c1"># Initialize arrays for variogram</span>
        <span class="n">gamma_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span>
        <span class="n">pair_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span>
        
        <span class="c1"># Calculate semivariance for each distance bin</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)):</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                
                <span class="c1"># Find which bin this distance falls into</span>
                <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">distance_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bin_idx</span> <span class="o">&lt;</span> <span class="n">n_bins</span><span class="p">:</span>
                    <span class="c1"># Calculate squared difference</span>
                    <span class="n">value_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">values_valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">values_valid</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
                    
                    <span class="c1"># Add to variogram</span>
                    <span class="n">gamma_values</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value_diff</span>
                    <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Calculate semivariance</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">gamma_values</span> <span class="o">=</span> <span class="n">gamma_values</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pair_counts</span><span class="p">)</span>
        
        <span class="c1"># Replace NaNs with 0</span>
        <span class="n">gamma_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">gamma_values</span><span class="p">)</span>
        
        <span class="c1"># Fit variogram model (spherical model)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">spherical_model</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            
            <span class="c1"># Calculate model values</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="n">range_param</span>
            <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">nugget</span> <span class="o">+</span> <span class="p">(</span><span class="n">sill</span> <span class="o">-</span> <span class="n">nugget</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">range_param</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">range_param</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">nugget</span> <span class="o">+</span> <span class="p">(</span><span class="n">sill</span> <span class="o">-</span> <span class="n">nugget</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">result</span>
        
        <span class="c1"># Function to fit</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">fit_func</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">spherical_model</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Initial parameter guesses</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span>
                <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">values_valid</span><span class="p">),</span>  <span class="c1"># nugget</span>
                <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">values_valid</span><span class="p">),</span>       <span class="c1"># sill</span>
                <span class="n">max_dist</span> <span class="o">/</span> <span class="mi">3</span>                <span class="c1"># range</span>
            <span class="p">]</span>
            
            <span class="c1"># Fit model to experimental variogram</span>
            <span class="n">valid_bins</span> <span class="o">=</span> <span class="n">pair_counts</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 4 points for fitting</span>
                <span class="n">popt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                    <span class="n">fit_func</span><span class="p">,</span> 
                    <span class="n">distance_centers</span><span class="p">[</span><span class="n">valid_bins</span><span class="p">],</span> 
                    <span class="n">gamma_values</span><span class="p">[</span><span class="n">valid_bins</span><span class="p">],</span> 
                    <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
                <span class="p">)</span>
                
                <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span> <span class="o">=</span> <span class="n">popt</span>
                
                <span class="c1"># Calculate fitted values</span>
                <span class="n">fitted_values</span> <span class="o">=</span> <span class="n">spherical_model</span><span class="p">(</span><span class="n">distance_centers</span><span class="p">,</span> <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">fitted_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distance_centers</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">nugget</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">range_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fitted_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distance_centers</span><span class="p">)</span>
        
        <span class="c1"># Calculate spatial heterogeneity metrics</span>
        <span class="n">spatial_dependence</span> <span class="o">=</span> <span class="p">(</span><span class="n">sill</span> <span class="o">-</span> <span class="n">nugget</span><span class="p">)</span> <span class="o">/</span> <span class="n">sill</span> <span class="k">if</span> <span class="n">sill</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Store results</span>
        <span class="n">heterogeneity_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;variogram&#39;</span><span class="p">,</span>
            <span class="s1">&#39;nugget&#39;</span><span class="p">:</span> <span class="n">nugget</span><span class="p">,</span>
            <span class="s1">&#39;sill&#39;</span><span class="p">:</span> <span class="n">sill</span><span class="p">,</span>
            <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="n">range_param</span><span class="p">,</span>
            <span class="s1">&#39;spatial_dependence&#39;</span><span class="p">:</span> <span class="n">spatial_dependence</span><span class="p">,</span>
            <span class="s1">&#39;n_bins&#39;</span><span class="p">:</span> <span class="n">n_bins</span><span class="p">,</span>
            <span class="s1">&#39;max_dist&#39;</span><span class="p">:</span> <span class="n">max_dist</span>
        <span class="p">}</span>
        
        <span class="c1"># Prepare variogram data for plotting</span>
        <span class="n">grid_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;distance_centers&#39;</span><span class="p">:</span> <span class="n">distance_centers</span><span class="p">,</span>
            <span class="s1">&#39;gamma_values&#39;</span><span class="p">:</span> <span class="n">gamma_values</span><span class="p">,</span>
            <span class="s1">&#39;fitted_values&#39;</span><span class="p">:</span> <span class="n">fitted_values</span><span class="p">,</span>
            <span class="s1">&#39;pair_counts&#39;</span><span class="p">:</span> <span class="n">pair_counts</span>
        <span class="p">}</span>
    
    <span class="c1"># Detect and characterize spatial gradients if requested</span>
    <span class="n">gradient_metrics</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">gradient_detection</span><span class="p">:</span>
        <span class="c1"># Create a grid of values for gradient detection</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quadrat&#39;</span><span class="p">:</span>
            <span class="c1"># Use already computed quadrat means</span>
            <span class="n">value_grid</span> <span class="o">=</span> <span class="n">quadrat_means</span>
            <span class="n">x_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">y_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kernel&#39;</span><span class="p">:</span>
            <span class="c1"># Use kernel density estimation</span>
            <span class="n">value_grid</span> <span class="o">=</span> <span class="n">density_grid</span>
            <span class="n">x_centers</span> <span class="o">=</span> <span class="n">x_grid</span>
            <span class="n">y_centers</span> <span class="o">=</span> <span class="n">y_grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a new grid</span>
            <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="n">grid_size</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># Number of grid cells in each dimension</span>
            <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">grid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">grid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Count cells in each grid cell and calculate average values</span>
            <span class="n">value_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">))</span>
            <span class="n">count_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_valid</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">values_valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># Find which grid cell this point belongs to</span>
                <span class="n">x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="n">grid_size</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="n">grid_size</span><span class="p">:</span>
                    <span class="n">value_grid</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
                    <span class="n">count_grid</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Calculate average value in each grid cell</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">value_grid</span> <span class="o">=</span> <span class="n">value_grid</span> <span class="o">/</span> <span class="n">count_grid</span>
            
            <span class="c1"># Replace NaNs with neighborhood average</span>
            <span class="n">value_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">value_grid</span><span class="p">)</span>
            
            <span class="c1"># Smooth grid with Gaussian filter</span>
            <span class="n">value_grid</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">value_grid</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="n">x_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">y_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        
        <span class="c1"># Calculate gradients</span>
        <span class="n">grad_y</span><span class="p">,</span> <span class="n">grad_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">value_grid</span><span class="p">)</span>
        
        <span class="c1"># Calculate gradient magnitude and direction</span>
        <span class="n">grad_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">grad_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">grad_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">grad_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">grad_y</span><span class="p">,</span> <span class="n">grad_x</span><span class="p">)</span>
        
        <span class="c1"># Calculate average gradient magnitude</span>
        <span class="n">avg_grad_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grad_magnitude</span><span class="p">)</span>
        <span class="n">max_grad_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">grad_magnitude</span><span class="p">)</span>
        
        <span class="c1"># Detect major gradient direction</span>
        <span class="n">weighted_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grad_direction</span> <span class="o">*</span> <span class="n">grad_magnitude</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grad_magnitude</span><span class="p">)</span>
        
        <span class="c1"># Convert to degrees</span>
        <span class="n">direction_degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">weighted_direction</span><span class="p">)</span>
        
        <span class="c1"># Fit gradient model</span>
        <span class="c1"># Define mesh grid for fitting</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_centers</span><span class="p">,</span> <span class="n">y_centers</span><span class="p">)</span>
        
        <span class="c1"># Flatten arrays for regression</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">value_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1"># Add constant term</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">X</span><span class="p">])</span>
        
        <span class="c1"># Fit linear model</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Calculate predicted values</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            
            <span class="c1"># Reshape to grid</span>
            <span class="n">y_pred_grid</span> <span class="o">=</span> <span class="n">y_pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">value_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
            <span class="c1"># Calculate R^2</span>
            <span class="n">ss_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ss_residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">r_squared</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">ss_residual</span> <span class="o">/</span> <span class="n">ss_total</span><span class="p">)</span>
            
            <span class="c1"># Calculate fitted gradient parameters</span>
            <span class="n">gradient_intercept</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">gradient_x</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">gradient_y</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="c1"># Calculate fitted gradient magnitude and direction</span>
            <span class="n">fitted_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gradient_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gradient_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">fitted_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">gradient_y</span><span class="p">,</span> <span class="n">gradient_x</span><span class="p">)</span>
            <span class="n">fitted_direction_degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">fitted_direction</span><span class="p">)</span>
            
            <span class="c1"># Determine if gradient is significant</span>
            <span class="n">is_gradient_significant</span> <span class="o">=</span> <span class="n">r_squared</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="ow">and</span> <span class="n">fitted_magnitude</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="n">value_max</span> <span class="o">-</span> <span class="n">value_min</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">gradient_intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">gradient_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">gradient_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fitted_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fitted_direction_degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">r_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">is_gradient_significant</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">y_pred_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">value_grid</span><span class="p">)</span>
        
        <span class="c1"># Store gradient metrics</span>
        <span class="n">gradient_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;avg_magnitude&#39;</span><span class="p">:</span> <span class="n">avg_grad_magnitude</span><span class="p">,</span>
            <span class="s1">&#39;max_magnitude&#39;</span><span class="p">:</span> <span class="n">max_grad_magnitude</span><span class="p">,</span>
            <span class="s1">&#39;direction_degrees&#39;</span><span class="p">:</span> <span class="n">direction_degrees</span><span class="p">,</span>
            <span class="s1">&#39;fitted_magnitude&#39;</span><span class="p">:</span> <span class="n">fitted_magnitude</span><span class="p">,</span>
            <span class="s1">&#39;fitted_direction_degrees&#39;</span><span class="p">:</span> <span class="n">fitted_direction_degrees</span><span class="p">,</span>
            <span class="s1">&#39;r_squared&#39;</span><span class="p">:</span> <span class="n">r_squared</span><span class="p">,</span>
            <span class="s1">&#39;is_significant&#39;</span><span class="p">:</span> <span class="n">is_gradient_significant</span><span class="p">,</span>
            <span class="s1">&#39;gradient_x&#39;</span><span class="p">:</span> <span class="n">gradient_x</span><span class="p">,</span>
            <span class="s1">&#39;gradient_y&#39;</span><span class="p">:</span> <span class="n">gradient_y</span><span class="p">,</span>
            <span class="s1">&#39;intercept&#39;</span><span class="p">:</span> <span class="n">gradient_intercept</span>
        <span class="p">}</span>
        
        <span class="c1"># Add gradient data to grid_data</span>
        <span class="n">grid_data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;grad_magnitude&#39;</span><span class="p">:</span> <span class="n">grad_magnitude</span><span class="p">,</span>
            <span class="s1">&#39;grad_direction&#39;</span><span class="p">:</span> <span class="n">grad_direction</span><span class="p">,</span>
            <span class="s1">&#39;fitted_grid&#39;</span><span class="p">:</span> <span class="n">y_pred_grid</span>
        <span class="p">})</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="n">plot_config</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quadrat&#39;</span><span class="p">:</span>
            <span class="c1"># Heatmap of quadrat values</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;heatmap&#39;</span><span class="p">,</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">quadrat_means</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x_grid</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y_grid</span><span class="p">,</span>
                <span class="s1">&#39;colormap&#39;</span><span class="p">:</span> <span class="s1">&#39;viridis&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Spatial Heterogeneity of </span><span class="si">{</span><span class="n">analysis_name</span><span class="si">}</span><span class="s1"> (Quadrat Analysis)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="n">x_col</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="n">y_col</span><span class="p">,</span>
                <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="n">coords_valid</span><span class="p">,</span>  <span class="c1"># Overlay cell positions</span>
                <span class="s1">&#39;point_values&#39;</span><span class="p">:</span> <span class="n">values_valid</span><span class="p">,</span>  <span class="c1"># Color points by their values</span>
                <span class="s1">&#39;gradient_arrows&#39;</span><span class="p">:</span> <span class="n">gradient_detection</span>  <span class="c1"># Show gradient arrows if gradient detection was performed</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kernel&#39;</span><span class="p">:</span>
            <span class="c1"># Heatmap of kernel density</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;heatmap&#39;</span><span class="p">,</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">density_grid</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x_grid</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y_grid</span><span class="p">,</span>
                <span class="s1">&#39;colormap&#39;</span><span class="p">:</span> <span class="s1">&#39;viridis&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Spatial Heterogeneity of </span><span class="si">{</span><span class="n">analysis_name</span><span class="si">}</span><span class="s1"> (Kernel Density)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="n">x_col</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="n">y_col</span><span class="p">,</span>
                <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="n">coords_valid</span><span class="p">,</span>  <span class="c1"># Overlay cell positions</span>
                <span class="s1">&#39;point_values&#39;</span><span class="p">:</span> <span class="n">values_valid</span><span class="p">,</span>  <span class="c1"># Color points by their values</span>
                <span class="s1">&#39;gradient_arrows&#39;</span><span class="p">:</span> <span class="n">gradient_detection</span>  <span class="c1"># Show gradient arrows if gradient detection was performed</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span>
            <span class="c1"># Scatter plot of nearest neighbor relationships</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;scatter&#39;</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;nn_dist&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;value_diff&#39;</span><span class="p">,</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">nn_df</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Nearest Neighbor Analysis of </span><span class="si">{</span><span class="n">analysis_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance to nearest neighbor (pixels)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Absolute value difference&#39;</span><span class="p">,</span>
                <span class="s1">&#39;trendline&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># Add trendline</span>
                <span class="s1">&#39;correlation&#39;</span><span class="p">:</span> <span class="n">heterogeneity_metrics</span><span class="p">[</span><span class="s1">&#39;correlation&#39;</span><span class="p">],</span>  <span class="c1"># Show correlation</span>
                <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="kc">True</span>  <span class="c1"># Show points</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;variogram&#39;</span><span class="p">:</span>
            <span class="c1"># Plot experimental variogram and fitted model</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">distance_centers</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">gamma_values</span><span class="p">,</span>
                <span class="s1">&#39;y2&#39;</span><span class="p">:</span> <span class="n">fitted_values</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Variogram Analysis of </span><span class="si">{</span><span class="n">analysis_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Semivariance&#39;</span><span class="p">,</span>
                <span class="s1">&#39;legend&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Experimental&#39;</span><span class="p">,</span> <span class="s1">&#39;Fitted model&#39;</span><span class="p">],</span>
                <span class="s1">&#39;x_range&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">],</span>
                <span class="s1">&#39;y_range&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># Auto-scale upper limit</span>
            <span class="p">}</span>
    
    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;global_metrics&#39;</span><span class="p">:</span> <span class="n">global_metrics</span><span class="p">,</span>
        <span class="s1">&#39;heterogeneity_metrics&#39;</span><span class="p">:</span> <span class="n">heterogeneity_metrics</span><span class="p">,</span>
        <span class="s1">&#39;gradient_metrics&#39;</span><span class="p">:</span> <span class="n">gradient_metrics</span><span class="p">,</span>
        <span class="s1">&#39;grid_data&#39;</span><span class="p">:</span> <span class="n">grid_data</span><span class="p">,</span>
        <span class="s1">&#39;plot_config&#39;</span><span class="p">:</span> <span class="n">plot_config</span>
    <span class="p">}</span>        </div>




<span class="c1"># Network-Based Analysis</span>
<div class="viewcode-block" id="calculate_mark_correlation">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_mark_correlation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_mark_correlation</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                              <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mark_type</span><span class="o">=</span><span class="s1">&#39;continuous&#39;</span><span class="p">,</span>
                              <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the mark correlation function to analyze spatial correlation of cell attributes.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        attribute_name: Name of the attribute/column in adata.obs to analyze</span>
<span class="sd">        max_distance: Maximum distance to consider (in pixels)</span>
<span class="sd">        num_bins: Number of distance bins for the correlation function</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        mark_type: Type of attribute (&#39;continuous&#39; or &#39;categorical&#39;)</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for confidence envelope (0 for none)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distances and mark correlation values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get attribute values from AnnData object</span>
    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary mapping cell IDs to attribute values</span>
    <span class="n">cell_to_attr</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Add attribute values to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_attr</span><span class="p">)</span>
    
    <span class="c1"># Drop cells with missing attribute values</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">])</span>
    
    <span class="c1"># Extract coordinates and attribute values</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">marks</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Check if attribute is categorical and convert if necessary</span>
    <span class="k">if</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
        <span class="c1"># Convert categorical marks to numeric labels</span>
        <span class="n">unique_categories</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
        <span class="n">category_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_categories</span><span class="p">)}</span>
        <span class="n">marks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">category_to_idx</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">marks</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Ensure marks are numeric for continuous attributes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">marks</span> <span class="o">=</span> <span class="n">marks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&#39; contains non-numeric values but mark_type is &#39;continuous&#39;&quot;</span><span class="p">)</span>
    
    <span class="c1"># Normalize marks to [0, 1] for easier interpretation</span>
    <span class="k">if</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="n">mark_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
        <span class="n">mark_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">mark_min</span> <span class="o">!=</span> <span class="n">mark_max</span><span class="p">:</span>  <span class="c1"># Avoid division by zero</span>
            <span class="n">marks</span> <span class="o">=</span> <span class="p">(</span><span class="n">marks</span> <span class="o">-</span> <span class="n">mark_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mark_max</span> <span class="o">-</span> <span class="n">mark_min</span><span class="p">)</span>
    
    <span class="c1"># Calculate distance bins</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate pairwise distances</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Calculate mark correlation function</span>
    <span class="k">if</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="c1"># For continuous marks, calculate the mark correlation function</span>
        <span class="c1"># This measures whether similar marks are found close together</span>
        
        <span class="c1"># Calculate global mean and variance of marks</span>
        <span class="n">global_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
        <span class="n">global_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
        
        <span class="c1"># Initialize arrays for correlation calculation</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
        
        <span class="c1"># Calculate mark correlation for each distance bin</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>  <span class="c1"># Only consider unique pairs</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">:</span>
                    <span class="c1"># Determine which bin this distance falls into</span>
                    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bin_idx</span> <span class="o">&lt;</span> <span class="n">num_bins</span><span class="p">:</span>
                        <span class="c1"># Calculate the product of centered marks</span>
                        <span class="n">mark_product</span> <span class="o">=</span> <span class="p">(</span><span class="n">marks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">global_mean</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">marks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">global_mean</span><span class="p">)</span>
                        
                        <span class="c1"># Add to numerator</span>
                        <span class="n">numerator</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mark_product</span>
                        
                        <span class="c1"># Add to denominator (squared centered marks)</span>
                        <span class="n">denominator</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Calculate mark correlation function</span>
        <span class="c1"># C(r) = E[(m_i - )(m_j - )] / </span>
        <span class="n">mark_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">denominator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mark_correlation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numerator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">denominator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">global_variance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mark_correlation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Categorical marks</span>
        <span class="c1"># For categorical marks, calculate co-occurrence probability</span>
        <span class="c1"># This measures whether specific categories tend to be found together</span>
        
        <span class="c1"># Get the number of categories</span>
        <span class="n">num_categories</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">marks</span><span class="p">))</span>
        
        <span class="c1"># Initialize arrays for co-occurrence calculation</span>
        <span class="c1"># Dimension: [distance bins, category 1, category 2]</span>
        <span class="n">mark_co_occurrence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">))</span>
        <span class="n">pair_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">))</span>
        
        <span class="c1"># Calculate co-occurrence for each distance bin</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>  <span class="c1"># Only consider unique pairs</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">:</span>
                    <span class="c1"># Determine which bin this distance falls into</span>
                    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bin_idx</span> <span class="o">&lt;</span> <span class="n">num_bins</span><span class="p">:</span>
                        <span class="c1"># Get categories of the two cells</span>
                        <span class="n">cat_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">marks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">cat_j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">marks</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        
                        <span class="c1"># Increment co-occurrence count</span>
                        <span class="n">mark_co_occurrence</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">cat_i</span><span class="p">,</span> <span class="n">cat_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">mark_co_occurrence</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">cat_j</span><span class="p">,</span> <span class="n">cat_i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Symmetric</span>
                        
                        <span class="c1"># Increment pair count</span>
                        <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">cat_i</span><span class="p">,</span> <span class="n">cat_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">pair_counts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">cat_j</span><span class="p">,</span> <span class="n">cat_i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Symmetric</span>
        
        <span class="c1"># Calculate co-occurrence probability (normalized)</span>
        <span class="n">mark_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cat1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cat2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mark_correlation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mark_co_occurrence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">]</span> <span class="o">/</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">]</span>
    
    <span class="c1"># Create result DataFrame</span>
    <span class="k">if</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">bin_centers</span><span class="p">,</span>
            <span class="s1">&#39;mark_correlation&#39;</span><span class="p">:</span> <span class="n">mark_correlation</span><span class="p">,</span>
            <span class="s1">&#39;n_pairs&#39;</span><span class="p">:</span> <span class="n">denominator</span>
        <span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Categorical</span>
        <span class="c1"># For categorical marks, create a multi-index DataFrame</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cat1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cat2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="s1">&#39;category1&#39;</span><span class="p">:</span> <span class="n">unique_categories</span><span class="p">[</span><span class="n">cat1</span><span class="p">],</span>
                            <span class="s1">&#39;category2&#39;</span><span class="p">:</span> <span class="n">unique_categories</span><span class="p">[</span><span class="n">cat2</span><span class="p">],</span>
                            <span class="s1">&#39;co_occurrence&#39;</span><span class="p">:</span> <span class="n">mark_correlation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">],</span>
                            <span class="s1">&#39;n_pairs&#39;</span><span class="p">:</span> <span class="n">pair_counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">]</span>
                        <span class="p">})</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    
    <span class="c1"># Calculate Monte Carlo confidence envelope if requested</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate mark correlation for randomized marks</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_mark_correlation</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Randomly permute the marks</span>
            <span class="n">random_marks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
            
            <span class="c1"># Calculate global mean and variance of random marks</span>
            <span class="n">random_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">random_marks</span><span class="p">)</span>
            <span class="n">random_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">random_marks</span><span class="p">)</span>
            
            <span class="c1"># Initialize arrays for correlation calculation</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Calculate mark correlation for each distance bin</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>  <span class="c1"># Only consider unique pairs</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">:</span>
                        <span class="c1"># Determine which bin this distance falls into</span>
                        <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                        
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bin_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># Calculate the product of centered marks</span>
                            <span class="n">mark_product</span> <span class="o">=</span> <span class="p">(</span><span class="n">random_marks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">random_mean</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">random_marks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">random_mean</span><span class="p">)</span>
                            
                            <span class="c1"># Add to numerator</span>
                            <span class="n">numerator</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mark_product</span>
                            
                            <span class="c1"># Add to denominator (number of pairs)</span>
                            <span class="n">denominator</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Calculate mark correlation function</span>
            <span class="n">random_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">denominator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">random_variance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">random_correlation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numerator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">denominator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">random_variance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">random_correlation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">return</span> <span class="n">random_correlation</span>
        
        <span class="c1"># Run Monte Carlo simulations in parallel</span>
        <span class="n">mc_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_mark_correlation</span><span class="p">)(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">max_distance</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Monte Carlo simulations&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="c1"># Stack results for easier processing</span>
        <span class="n">mc_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mc_results</span><span class="p">)</span>
        
        <span class="c1"># Calculate confidence envelopes (2.5% and 97.5% percentiles)</span>
        <span class="n">correlation_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_correlation</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">correlation_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc_correlation</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Add to result DataFrame</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;correlation_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correlation_low</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;correlation_high&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correlation_high</span>
        
        <span class="c1"># Determine if observed correlation is significantly different from random</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_positive_correlation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;mark_correlation&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;correlation_high&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_negative_correlation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;mark_correlation&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;correlation_low&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_significant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_positive_correlation&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_negative_correlation&#39;</span><span class="p">]</span>
    
    <span class="c1"># Interpret the mark correlation function</span>
    <span class="c1"># For continuous marks:</span>
    <span class="c1"># - C(r) &gt; 0: Positive spatial correlation (similar marks tend to be close together)</span>
    <span class="c1"># - C(r) = 0: No spatial correlation (marks are spatially independent)</span>
    <span class="c1"># - C(r) &lt; 0: Negative spatial correlation (similar marks tend to be far apart)</span>
    
    <span class="k">if</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="c1"># Add interpretation column</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No correlation&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;mark_correlation&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Positive correlation&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;mark_correlation&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Negative correlation&#39;</span>
        
        <span class="c1"># If we have significance testing, refine the interpretation</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No correlation (Not Significant)&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_positive_correlation&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Positive correlation (Significant)&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;is_negative_correlation&#39;</span><span class="p">],</span> <span class="s1">&#39;interpretation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Negative correlation (Significant)&#39;</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mark_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
            <span class="c1"># Define plot configuration for continuous marks</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;mark_correlation&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Mark Correlation Function for </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s2">&quot;All cells&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Mark Correlation&#39;</span><span class="p">,</span>
                <span class="s1">&#39;reference_line&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Add a horizontal line at C(r) = 0</span>
                <span class="s1">&#39;confidence_intervals&#39;</span><span class="p">:</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># Add confidence intervals if available</span>
                <span class="s1">&#39;ci_low&#39;</span><span class="p">:</span> <span class="s1">&#39;correlation_low&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ci_high&#39;</span><span class="p">:</span> <span class="s1">&#39;correlation_high&#39;</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Categorical</span>
            <span class="c1"># Define plot configuration for categorical marks</span>
            <span class="c1"># This will be a separate plot for each category pair</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;co_occurrence&#39;</span><span class="p">,</span>
                <span class="s1">&#39;hue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;category1&#39;</span><span class="p">,</span> <span class="s1">&#39;category2&#39;</span><span class="p">],</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Mark Co-occurrence for </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;subtitle&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s2">&quot;All cells&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Co-occurrence Probability&#39;</span><span class="p">,</span>
                <span class="s1">&#39;legend&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_spatial_context">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_spatial_context">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_spatial_context</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="p">,</span> 
                            <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">weight_by_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">context_types</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the spatial context of cells based on their local neighborhood composition.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        distance_threshold: Maximum distance (in pixels) to consider cells as neighbors</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        use_polygons: Whether to use cell polygons for spatial relationships (True) or cell centers (False)</span>
<span class="sd">        weight_by_distance: Whether to weight neighbors by inverse distance (True) or use binary weights (False)</span>
<span class="sd">        context_types: Which cell types to include in context analysis (&#39;all&#39; or list of cell types)</span>
<span class="sd">        normalize: Whether to normalize context proportions (True) or use raw counts (False)</span>
<span class="sd">        min_neighbors: Minimum number of neighbors required for valid context analysis</span>
<span class="sd">        n_jobs: Number of parallel jobs for context calculation (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with cell IDs and their spatial context profiles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.manifold</span><span class="w"> </span><span class="kn">import</span> <span class="n">TSNE</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_global_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_local_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_center_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_center_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check if cell type column exists</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
        
    <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
    <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    
    <span class="c1"># Add cell type information to the cells DataFrame</span>
    <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Drop cells without cell type information</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">])</span>
    
    <span class="c1"># Check if we have polygons data if using polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polygon data not available in the Spatioloji object&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates and cell IDs</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_center_col</span><span class="p">,</span> <span class="n">y_center_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_types</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Determine which cell types to include in context analysis</span>
    <span class="k">if</span> <span class="n">context_types</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">unique_cell_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">context_cell_types</span> <span class="o">=</span> <span class="n">unique_cell_types</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Validate that specified types exist in the data</span>
        <span class="n">unique_cell_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">invalid_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">context_types</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">unique_cell_types</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">invalid_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Specified cell types not found in data: </span><span class="si">{</span><span class="n">invalid_types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">context_cell_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">context_types</span><span class="p">)</span>
    
    <span class="c1"># Create mapping from cell type to index</span>
    <span class="n">type_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">context_cell_types</span><span class="p">)}</span>
    
    <span class="c1"># If using polygons, create cell polygons</span>
    <span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="c1"># Group polygons by cell</span>
        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
            <span class="n">cell_poly_data</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_polygon_for_cell</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
            
            <span class="c1"># Skip if no polygon data found for this cell</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Create a polygon from the points</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">[</span><span class="n">x_poly_col</span><span class="p">],</span> <span class="n">cell_poly_data</span><span class="p">[</span><span class="n">y_poly_col</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for a polygon</span>
                    <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create polygon for cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate pairwise distances if not using polygons</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Function to calculate spatial context for a single cell</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_cell_context</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cell_id</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">):</span>
        <span class="c1"># Initialize context vector</span>
        <span class="n">context_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">context_cell_types</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="c1"># Skip if no polygon data for this cell</span>
            <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                    <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">cell_type</span><span class="p">,</span>
                    <span class="s1">&#39;context_vector&#39;</span><span class="p">:</span> <span class="n">context_vector</span><span class="p">,</span>
                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            
            <span class="c1"># Get polygon for this cell</span>
            <span class="n">poly1</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
            
            <span class="c1"># Calculate distances to all other cell polygons</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">other_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">cell_id</span> <span class="o">==</span> <span class="n">other_id</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Skip if no polygon data for other cell</span>
                <span class="k">if</span> <span class="n">other_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Get polygon for other cell</span>
                <span class="n">poly2</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">other_id</span><span class="p">]</span>
                
                <span class="c1"># Calculate distance between polygons</span>
                <span class="n">distance_between</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">poly2</span><span class="p">)</span>
                
                <span class="c1"># Check if neighbor is within threshold</span>
                <span class="k">if</span> <span class="n">distance_between</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">:</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="n">cell_types</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    
                    <span class="c1"># Only include cell types specified in context_cell_types</span>
                    <span class="k">if</span> <span class="n">other_type</span> <span class="ow">in</span> <span class="n">type_to_idx</span><span class="p">:</span>
                        <span class="c1"># Calculate weight (inverse of distance or binary)</span>
                        <span class="k">if</span> <span class="n">weight_by_distance</span><span class="p">:</span>
                            <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">distance_between</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
                        
                        <span class="c1"># Add to neighbors list</span>
                        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">other_type</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate distances to all other cells</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># Find neighbors within threshold</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">distance_between</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="k">if</span> <span class="n">distance_between</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">:</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="n">cell_types</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    
                    <span class="c1"># Only include cell types specified in context_cell_types</span>
                    <span class="k">if</span> <span class="n">other_type</span> <span class="ow">in</span> <span class="n">type_to_idx</span><span class="p">:</span>
                        <span class="c1"># Calculate weight (inverse of distance or binary)</span>
                        <span class="k">if</span> <span class="n">weight_by_distance</span><span class="p">:</span>
                            <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">distance_between</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
                        
                        <span class="c1"># Add to neighbors list</span>
                        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">other_type</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        
        <span class="c1"># Check if cell has enough neighbors</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;</span> <span class="n">min_neighbors</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">cell_type</span><span class="p">,</span>
                <span class="s1">&#39;context_vector&#39;</span><span class="p">:</span> <span class="n">context_vector</span><span class="p">,</span>
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="n">n_neighbors</span><span class="p">,</span>
                <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="kc">False</span>
            <span class="p">}</span>
        
        <span class="c1"># Aggregate neighbors by cell type</span>
        <span class="k">for</span> <span class="n">neighbor_type</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="n">type_idx</span> <span class="o">=</span> <span class="n">type_to_idx</span><span class="p">[</span><span class="n">neighbor_type</span><span class="p">]</span>
            <span class="n">context_vector</span><span class="p">[</span><span class="n">type_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        
        <span class="c1"># Normalize context vector if requested</span>
        <span class="k">if</span> <span class="n">normalize</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">context_vector</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">context_vector</span> <span class="o">=</span> <span class="n">context_vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">context_vector</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
            <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">cell_type</span><span class="p">,</span>
            <span class="s1">&#39;context_vector&#39;</span><span class="p">:</span> <span class="n">context_vector</span><span class="p">,</span>
            <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="n">n_neighbors</span><span class="p">,</span>
            <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    
    <span class="c1"># Calculate spatial context for all cells in parallel</span>
    <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_cell_context</span><span class="p">)(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">cell_id</span><span class="p">,</span> <span class="n">cell_type</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">))</span>
    <span class="p">)</span>
    
    <span class="c1"># Convert results to DataFrame</span>
    <span class="n">context_data</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]:</span>
            <span class="c1"># Create row with cell ID and type</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">],</span>
                <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">],</span>
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span>
            <span class="p">}</span>
            
            <span class="c1"># Add context proportions for each cell type</span>
            <span class="k">for</span> <span class="n">cell_type</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">type_to_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">row</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;context_vector&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            
            <span class="c1"># Add to data list</span>
            <span class="n">context_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    
    <span class="c1"># Create DataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">context_data</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid spatial context profiles could be calculated. Try increasing distance_threshold or decreasing min_neighbors.&quot;</span><span class="p">)</span>
    
    <span class="n">context_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">context_data</span><span class="p">)</span>
    
    <span class="c1"># Convert context vectors to matrix for clustering</span>
    <span class="n">context_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">context_df</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">context_cell_types</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">context_df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">context_cell_types</span><span class="p">):</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">context_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>
    
    <span class="c1"># Perform clustering on context profiles</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context_df</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># Need at least 5 points for meaningful clustering</span>
        <span class="c1"># Determine optimal number of clusters (2-10)</span>
        <span class="n">best_k</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">context_df</span><span class="p">))):</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">context_matrix</span><span class="p">)</span>
            
            <span class="c1"># Calculate silhouette score</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Ensure more than one cluster</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">silhouette_score</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span><span class="n">context_matrix</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                    <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                    <span class="n">best_k</span> <span class="o">=</span> <span class="n">k</span>
        
        <span class="c1"># Perform KMeans clustering with optimal k</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">best_k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;context_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">context_matrix</span><span class="p">)</span>
        
        <span class="c1"># Calculate cluster centers</span>
        <span class="n">cluster_centers</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> 
                                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">context_cell_types</span><span class="p">])</span>
        <span class="n">cluster_centers</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_centers</span><span class="p">))</span>
        
        <span class="c1"># Add dominant cell type in each cluster</span>
        <span class="n">dominant_types</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cluster_centers</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">type_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">context_cell_types</span><span class="p">}</span>
            <span class="n">dominant_type</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">type_props</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dominant_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dominant_type</span><span class="p">)</span>
        
        <span class="n">cluster_centers</span><span class="p">[</span><span class="s1">&#39;dominant_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dominant_types</span>
        
        <span class="c1"># Add descriptive cluster names</span>
        <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;context_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;context_cluster&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">dominant_types</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="si">}</span><span class="s2"> enriched)&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If too few points for clustering, just assign all to one cluster</span>
        <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;context_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;context_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;All cells&quot;</span>
        <span class="n">cluster_centers</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Run t-SNE to visualize context profiles in 2D space</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context_df</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># Need at least 5 points for t-SNE</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tsne</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">tsne_coords</span> <span class="o">=</span> <span class="n">tsne</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">context_matrix</span><span class="p">)</span>
            
            <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;tsne_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tsne_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;tsne_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tsne_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    
    <span class="c1"># Add original coordinates</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">context_df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()):</span>
        <span class="n">cell_id</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">cell_id</span>
        <span class="n">cell_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cell_ids</span> <span class="o">==</span> <span class="n">cell_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">context_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">cell_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">context_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">cell_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Calculate neighborhood diversity for each cell</span>
    <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;diversity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">context_df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()):</span>
        <span class="c1"># Get context values</span>
        <span class="n">context_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">context_cell_types</span><span class="p">])</span>
        
        <span class="c1"># Calculate entropy (Shannon diversity)</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">context_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nonzero</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">context_values</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
            <span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="n">context_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="s1">&#39;diversity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropy</span>
    
    <span class="c1"># Calculate neighborhood specialization (inverse of diversity)</span>
    <span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;specialization&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;diversity&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">context_cell_types</span><span class="p">)))</span>
    
    <span class="c1"># Calculate neighborhood composition statistics</span>
    <span class="n">context_stats</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
        <span class="c1"># Get cells of this type</span>
        <span class="n">type_cells</span> <span class="o">=</span> <span class="n">context_df</span><span class="p">[</span><span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_cells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Calculate average context for this cell type</span>
            <span class="n">type_context</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">cell_type</span><span class="p">,</span>
                <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_cells</span><span class="p">),</span>
                <span class="s1">&#39;avg_neighbors&#39;</span><span class="p">:</span> <span class="n">type_cells</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                <span class="s1">&#39;avg_diversity&#39;</span><span class="p">:</span> <span class="n">type_cells</span><span class="p">[</span><span class="s1">&#39;diversity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                <span class="s1">&#39;avg_specialization&#39;</span><span class="p">:</span> <span class="n">type_cells</span><span class="p">[</span><span class="s1">&#39;specialization&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="p">}</span>
            
            <span class="c1"># Add average context proportions</span>
            <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">context_cell_types</span><span class="p">:</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;avg_context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">type_context</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_cells</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            
            <span class="c1"># Calculate standard errors</span>
            <span class="n">type_context</span><span class="p">[</span><span class="s1">&#39;se_neighbors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_cells</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_cells</span><span class="p">))</span>
            <span class="n">type_context</span><span class="p">[</span><span class="s1">&#39;se_diversity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_cells</span><span class="p">[</span><span class="s1">&#39;diversity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_cells</span><span class="p">))</span>
            <span class="n">type_context</span><span class="p">[</span><span class="s1">&#39;se_specialization&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_cells</span><span class="p">[</span><span class="s1">&#39;specialization&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_cells</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">context_cell_types</span><span class="p">:</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;se_context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">type_context</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_cells</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_cells</span><span class="p">))</span>
            
            <span class="n">context_stats</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_context</span>
    
    <span class="c1"># Calculate typical cell type niches</span>
    <span class="n">niche_clusters</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">cluster_centers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Create descriptive niches</span>
        <span class="n">niches</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cluster_centers</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># Get top 3 cell types in this niche</span>
            <span class="n">type_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;context_</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">context_cell_types</span><span class="p">}</span>
            <span class="n">sorted_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">type_props</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Create niche description</span>
            <span class="n">top_types</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">prop</span><span class="si">:</span><span class="s2">.1%</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">sorted_types</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">prop</span> <span class="o">&gt;</span> <span class="mf">0.05</span><span class="p">]</span>
            
            <span class="c1"># Add cluster info</span>
            <span class="n">niches</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                <span class="s1">&#39;dominant_type&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;dominant_type&#39;</span><span class="p">],</span>
                <span class="s1">&#39;composition&#39;</span><span class="p">:</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">top_types</span><span class="p">),</span>
                <span class="s1">&#39;cell_count&#39;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">context_df</span><span class="p">[</span><span class="s1">&#39;context_cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">})</span>
        
        <span class="n">niche_clusters</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">niches</span><span class="p">)</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="n">plot_config</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Determine which plot to generate based on what&#39;s available</span>
        <span class="k">if</span> <span class="s1">&#39;tsne_1&#39;</span> <span class="ow">in</span> <span class="n">context_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;tsne_2&#39;</span> <span class="ow">in</span> <span class="n">context_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># t-SNE plot of context profiles</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;scatter&#39;</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;tsne_1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;tsne_2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;context_cluster&#39;</span> <span class="k">if</span> <span class="s1">&#39;context_cluster&#39;</span> <span class="ow">in</span> <span class="n">context_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Spatial Context Profiles (t-SNE)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;size_by&#39;</span><span class="p">:</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tooltip&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="s1">&#39;context_name&#39;</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="s1">&#39;diversity&#39;</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Spatial plot with context clusters</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;scatter&#39;</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;context_cluster&#39;</span> <span class="k">if</span> <span class="s1">&#39;context_cluster&#39;</span> <span class="ow">in</span> <span class="n">context_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Spatial Context Clusters&#39;</span><span class="p">,</span>
                <span class="s1">&#39;size_by&#39;</span><span class="p">:</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tooltip&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="s1">&#39;context_name&#39;</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="s1">&#39;diversity&#39;</span><span class="p">]</span>
            <span class="p">}</span>
    
    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;context_profiles&#39;</span><span class="p">:</span> <span class="n">context_df</span><span class="p">,</span>
        <span class="s1">&#39;context_stats&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">context_stats</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span>
        <span class="s1">&#39;cluster_centers&#39;</span><span class="p">:</span> <span class="n">cluster_centers</span><span class="p">,</span>
        <span class="s1">&#39;niche_clusters&#39;</span><span class="p">:</span> <span class="n">niche_clusters</span><span class="p">,</span>
        <span class="s1">&#39;plot_config&#39;</span><span class="p">:</span> <span class="n">plot_config</span>
    <span class="p">}</span></div>






<span class="c1"># Gene Expression Spatial Analysis</span>
<div class="viewcode-block" id="calculate_network_statistics">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_network_statistics">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_network_statistics</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_nearest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribute_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">weight_by_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">community_detection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">centrality_measures</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">use_polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edge_overlap_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate network-based spatial statistics by constructing a cell interaction network,</span>
<span class="sd">    with support for polygon-based cell geometries.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        distance_threshold: Maximum distance (in pixels) to consider cells as connected (None if using k_nearest)</span>
<span class="sd">        k_nearest: Number of nearest neighbors to connect for each cell (None if using distance_threshold)</span>
<span class="sd">        cell_type_column: Optional column name in adata.obs containing cell type information</span>
<span class="sd">        attribute_column: Optional column name in adata.obs containing attribute values for node analysis</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        directed: Whether to create a directed network (True) or undirected network (False)</span>
<span class="sd">        weight_by_distance: Whether to weight edges by inverse distance (True) or use binary weights (False)</span>
<span class="sd">        community_detection: Whether to perform community detection (True) or not (False)</span>
<span class="sd">        centrality_measures: Whether to calculate node centrality measures (True) or not (False)</span>
<span class="sd">        n_jobs: Number of parallel jobs for community detection and centrality calculation (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        use_polygons: Whether to use cell polygons for spatial relationships (True) or cell centers (False)</span>
<span class="sd">        edge_overlap_threshold: Minimum overlap ratio between polygon edges to create a connection (0.0-1.0)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dict containing network statistics, node metrics, and community structure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralClustering</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">silhouette_score</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">community</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">community_louvain</span>  <span class="c1"># python-louvain package</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">,</span> <span class="n">LineString</span>
    
    <span class="c1"># Check if either distance_threshold or k_nearest is provided when not using polygons</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">k_nearest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either distance_threshold or k_nearest must be provided when not using polygons&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">k_nearest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of distance_threshold or k_nearest should be provided when not using polygons&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_global_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_center_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
        <span class="n">x_poly_col</span> <span class="o">=</span> <span class="s1">&#39;x_local_px&#39;</span>
        <span class="n">y_poly_col</span> <span class="o">=</span> <span class="s1">&#39;y_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_center_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_center_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_center_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check if we have polygons data if using polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polygon data not available in the Spatioloji object&quot;</span><span class="p">)</span>
    
    <span class="c1"># Add cell type information if requested</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
    
    <span class="c1"># Add attribute information if requested</span>
    <span class="k">if</span> <span class="n">attribute_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">attribute_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute column &#39;</span><span class="si">{</span><span class="n">attribute_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to attribute values</span>
        <span class="n">cell_to_attr</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">attribute_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add attribute information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_attr</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates and cell IDs</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_center_col</span><span class="p">,</span> <span class="n">y_center_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># If using polygons, create cell polygons</span>
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="c1"># Group polygons by cell</span>
        <span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
            <span class="n">cell_poly_data</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_polygon_for_cell</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
            
            <span class="c1"># Skip if no polygon data found for this cell</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="c1"># Create a polygon from the points</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cell_poly_data</span><span class="p">[</span><span class="n">x_poly_col</span><span class="p">],</span> <span class="n">cell_poly_data</span><span class="p">[</span><span class="n">y_poly_col</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for a polygon</span>
                    <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create polygon for cell </span><span class="si">{</span><span class="n">cell_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate pairwise distances if not using polygons</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Create a network based on spatial relationships</span>
    <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    
    <span class="c1"># Add nodes with positions and attributes</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">):</span>
        <span class="n">node_attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">}</span>
        
        <span class="c1"># Add polygon if available</span>
        <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
            <span class="n">node_attrs</span><span class="p">[</span><span class="s1">&#39;polygon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
        
        <span class="c1"># Add cell type if available</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;cell_type&#39;</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">node_attrs</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span>
        
        <span class="c1"># Add attribute if available</span>
        <span class="k">if</span> <span class="n">attribute_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;attribute&#39;</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">node_attrs</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span>
        
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="o">**</span><span class="n">node_attrs</span><span class="p">)</span>
    
    <span class="c1"># Add edges based on spatial relationships</span>
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="c1"># Connect cells based on polygon proximity or overlap</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_id1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">):</span>
            <span class="c1"># Skip if no polygon data for this cell</span>
            <span class="k">if</span> <span class="n">cell_id1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">poly1</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id1</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cell_id2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">):</span>
                <span class="c1"># Skip self-connections and cells without polygon data</span>
                <span class="k">if</span> <span class="n">cell_id1</span> <span class="o">==</span> <span class="n">cell_id2</span> <span class="ow">or</span> <span class="n">cell_id2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="n">poly2</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id2</span><span class="p">]</span>
                
                <span class="c1"># Calculate distance between polygons</span>
                <span class="n">distance_between</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">poly2</span><span class="p">)</span>
                
                <span class="c1"># Check if polygons are in contact or overlap</span>
                <span class="k">if</span> <span class="n">distance_between</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">:</span>
                    <span class="c1"># Calculate weight based on distance or overlap</span>
                    <span class="k">if</span> <span class="n">weight_by_distance</span><span class="p">:</span>
                        <span class="c1"># Use inverse distance as weight</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">distance_between</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
                    
                    <span class="c1"># Add edge</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">cell_id1</span><span class="p">,</span> <span class="n">cell_id2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">distance_between</span><span class="p">)</span>
                
                <span class="c1"># If using edge overlap instead of distance threshold</span>
                <span class="k">elif</span> <span class="n">edge_overlap_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Get the boundary of each polygon</span>
                    <span class="n">boundary1</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">boundary2</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">poly2</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    
                    <span class="c1"># Check if boundaries overlap or are close</span>
                    <span class="k">if</span> <span class="n">boundary1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">boundary2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span><span class="p">:</span>
                        <span class="c1"># Calculate the overlap ratio</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># Create a buffer around each boundary to detect &quot;close&quot; edges</span>
                            <span class="n">buffer1</span> <span class="o">=</span> <span class="n">boundary1</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">distance_threshold</span><span class="p">)</span>
                            <span class="n">buffer2</span> <span class="o">=</span> <span class="n">boundary2</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">distance_threshold</span><span class="p">)</span>
                            
                            <span class="c1"># Calculate overlap</span>
                            <span class="n">overlap</span> <span class="o">=</span> <span class="n">buffer1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">buffer2</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>
                            <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">boundary1</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">boundary2</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                            
                            <span class="c1"># Add edge if overlap ratio exceeds threshold</span>
                            <span class="k">if</span> <span class="n">overlap_ratio</span> <span class="o">&gt;=</span> <span class="n">edge_overlap_threshold</span><span class="p">:</span>
                                <span class="c1"># Calculate weight based on overlap ratio</span>
                                <span class="n">weight</span> <span class="o">=</span> <span class="n">overlap_ratio</span> <span class="k">if</span> <span class="n">weight_by_distance</span> <span class="k">else</span> <span class="mf">1.0</span>
                                
                                <span class="c1"># Add edge</span>
                                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">cell_id1</span><span class="p">,</span> <span class="n">cell_id2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> 
                                          <span class="n">distance</span><span class="o">=</span><span class="n">distance_between</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap_ratio</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Error calculating overlap between cells </span><span class="si">{</span><span class="n">cell_id1</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">cell_id2</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
    <span class="k">elif</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Connect cells within distance threshold</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span><span class="p">:</span>
                    <span class="c1"># Calculate weight (inverse of distance)</span>
                    <span class="k">if</span> <span class="n">weight_by_distance</span><span class="p">:</span>
                        <span class="c1"># Avoid division by zero</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="mf">1e-10</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
                    
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cell_ids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Connect to k nearest neighbors</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)):</span>
            <span class="c1"># Get indices of k nearest neighbors</span>
            <span class="n">nearest_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">1</span><span class="p">:</span><span class="n">k_nearest</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Skip self (index 0)</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nearest_indices</span><span class="p">:</span>
                <span class="c1"># Calculate weight (inverse of distance)</span>
                <span class="k">if</span> <span class="n">weight_by_distance</span><span class="p">:</span>
                    <span class="c1"># Avoid division by zero</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="mf">1e-10</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
                
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cell_ids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
    
    <span class="c1"># Calculate basic network metrics</span>
    <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
    <span class="n">num_edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">density</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Check if the graph is connected</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span> <span class="ow">and</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="n">num_components</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">largest_component_size</span> <span class="o">=</span> <span class="n">num_nodes</span>
            <span class="n">avg_path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
            <span class="n">num_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
            <span class="n">largest_component_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components</span><span class="p">)</span>
            
            <span class="c1"># Calculate average path length and diameter for the largest component</span>
            <span class="n">largest_component</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">))</span>
            <span class="n">avg_path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">largest_component</span><span class="p">)</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">largest_component</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For directed graphs, use weakly connected components</span>
        <span class="k">if</span> <span class="n">directed</span> <span class="ow">and</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">weakly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
            <span class="n">num_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
            <span class="n">largest_component_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components</span><span class="p">)</span>
            
            <span class="c1"># Calculate average path length and diameter for the largest component</span>
            <span class="n">largest_component</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">))</span>
            
            <span class="c1"># Check if the largest component has more than one node</span>
            <span class="k">if</span> <span class="n">largest_component</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">avg_path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">largest_component</span><span class="p">)</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">largest_component</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_path_length</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_components</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">largest_component_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">avg_path_length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Calculate clustering coefficient if the graph has nodes</span>
    <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">clustering_coefficient</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">average_clustering</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">clustering_coefficient</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Calculate degree statistics</span>
    <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span>
        <span class="n">avg_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
        <span class="n">min_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
        <span class="n">max_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
        <span class="n">degree_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">avg_degree</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_degree</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_degree</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">degree_std</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Calculate centrality measures if requested</span>
    <span class="n">node_metrics</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">centrality_measures</span> <span class="ow">and</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Initialize dictionary to store node metrics</span>
        <span class="n">node_metrics_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">}</span>
        
        <span class="c1"># Calculate degree centrality</span>
        <span class="n">degree_centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">centrality</span> <span class="ow">in</span> <span class="n">degree_centrality</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;degree_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centrality</span>
        
        <span class="c1"># Calculate closeness centrality (only for connected components)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span> <span class="ow">and</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="n">closeness_centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">closeness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">centrality</span> <span class="ow">in</span> <span class="n">closeness_centrality</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;closeness_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centrality</span>
        <span class="k">elif</span> <span class="n">directed</span><span class="p">:</span>
            <span class="c1"># For directed graphs, calculate closeness centrality for strongly connected components</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">closeness_centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">closeness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">centrality</span> <span class="ow">in</span> <span class="n">closeness_centrality</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;closeness_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centrality</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># If there&#39;s an error (e.g., not strongly connected), assign zeros</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                    <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;closeness_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For disconnected graphs, calculate closeness centrality for each connected component</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
                <span class="n">subgraph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                <span class="n">closeness_centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">closeness_centrality</span><span class="p">(</span><span class="n">subgraph</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">centrality</span> <span class="ow">in</span> <span class="n">closeness_centrality</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;closeness_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centrality</span>
        
        <span class="c1"># Calculate betweenness centrality</span>
        <span class="n">betweenness_centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">centrality</span> <span class="ow">in</span> <span class="n">betweenness_centrality</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;betweenness_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centrality</span>
        
        <span class="c1"># Calculate eigenvector centrality (may not converge for all graphs)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">eigenvector_centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">centrality</span> <span class="ow">in</span> <span class="n">eigenvector_centrality</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;eigenvector_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centrality</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># If eigenvector centrality doesn&#39;t converge, assign zeros</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;eigenvector_centrality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Calculate local clustering coefficient</span>
        <span class="n">clustering_coefficients</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">coefficient</span> <span class="ow">in</span> <span class="n">clustering_coefficients</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;clustering_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefficient</span>
        
        <span class="c1"># Add polygon size metrics if using polygons</span>
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                    <span class="n">polygon</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
                    <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
                    <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;perimeter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">length</span>
                    
                    <span class="c1"># Calculate shape features</span>
                    <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Circularity (= 4 * area / perimeter^2)</span>
                        <span class="n">circularity</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">length</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;circularity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circularity</span>
                        
                        <span class="c1"># Solidity (= area / convex hull area)</span>
                        <span class="n">convex_hull</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">convex_hull</span>
                        <span class="n">solidity</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">convex_hull</span><span class="o">.</span><span class="n">area</span> <span class="k">if</span> <span class="n">convex_hull</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;solidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">solidity</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;circularity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">node_metrics_dict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;solidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Convert node metrics to DataFrame</span>
        <span class="n">node_metrics</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">node_metrics_dict</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        
        <span class="c1"># Add cell metadata</span>
        <span class="n">node_metrics</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">node_metrics</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="n">node_metrics</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">node_metrics</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_metrics</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">node_metrics</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">attribute_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_metrics</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attribute&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">node_metrics</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
    
    <span class="c1"># Perform community detection if requested</span>
    <span class="n">communities</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">modularity</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">community_detection</span> <span class="ow">and</span> <span class="n">num_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Use Louvain algorithm for community detection</span>
        <span class="n">partition</span> <span class="o">=</span> <span class="n">community_louvain</span><span class="o">.</span><span class="n">best_partition</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
        <span class="c1"># Calculate modularity</span>
        <span class="n">modularity</span> <span class="o">=</span> <span class="n">community_louvain</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
        
        <span class="c1"># Create DataFrame with community assignments</span>
        <span class="n">communities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="s1">&#39;community&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">})</span>
        
        <span class="n">communities</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Add cell metadata</span>
        <span class="n">communities</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">communities</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="n">communities</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">communities</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">communities</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">communities</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">attribute_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">communities</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attribute&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">communities</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        
        <span class="c1"># Calculate number of communities and size statistics</span>
        <span class="n">num_communities</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">community_sizes</span> <span class="o">=</span> <span class="n">communities</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;community&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">avg_community_size</span> <span class="o">=</span> <span class="n">community_sizes</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">min_community_size</span> <span class="o">=</span> <span class="n">community_sizes</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">max_community_size</span> <span class="o">=</span> <span class="n">community_sizes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="c1"># Determine optimal number of communities using silhouette score if graph is large enough</span>
        <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="c1"># Try different numbers of communities for spectral clustering</span>
            <span class="n">silhouette_scores</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_clusters_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">))</span>
            
            <span class="c1"># Create adjacency matrix for spectral clustering</span>
            <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">n_clusters</span> <span class="ow">in</span> <span class="n">n_clusters_range</span><span class="p">:</span>
                <span class="c1"># Perform spectral clustering</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">clustering</span> <span class="o">=</span> <span class="n">SpectralClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">affinity</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">,</span> 
                                                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">assign_labels</span><span class="o">=</span><span class="s1">&#39;kmeans&#39;</span><span class="p">)</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">)</span>
                    
                    <span class="c1"># Calculate silhouette score</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Ensure more than one cluster</span>
                        <span class="n">score</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
                        <span class="n">silhouette_scores</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">score</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">continue</span>
            
            <span class="c1"># Find optimal number of communities</span>
            <span class="k">if</span> <span class="n">silhouette_scores</span><span class="p">:</span>
                <span class="n">optimal_n_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">silhouette_scores</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optimal_n_clusters</span> <span class="o">=</span> <span class="n">num_communities</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">optimal_n_clusters</span> <span class="o">=</span> <span class="n">num_communities</span>
        
        <span class="c1"># Add community metrics</span>
        <span class="n">community_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;num_communities&#39;</span><span class="p">:</span> <span class="n">num_communities</span><span class="p">,</span>
            <span class="s1">&#39;avg_community_size&#39;</span><span class="p">:</span> <span class="n">avg_community_size</span><span class="p">,</span>
            <span class="s1">&#39;min_community_size&#39;</span><span class="p">:</span> <span class="n">min_community_size</span><span class="p">,</span>
            <span class="s1">&#39;max_community_size&#39;</span><span class="p">:</span> <span class="n">max_community_size</span><span class="p">,</span>
            <span class="s1">&#39;modularity&#39;</span><span class="p">:</span> <span class="n">modularity</span><span class="p">,</span>
            <span class="s1">&#39;optimal_n_clusters&#39;</span><span class="p">:</span> <span class="n">optimal_n_clusters</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">community_metrics</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Create edge list</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="n">u</span><span class="p">,</span>
            <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span>
            <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
            <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="c1"># Add overlap information if available</span>
        <span class="k">if</span> <span class="s1">&#39;overlap&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;overlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;overlap&#39;</span><span class="p">]</span>
        
        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_data</span><span class="p">)</span>
    
    <span class="n">edge_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    
    <span class="c1"># Calculate edge-specific statistics</span>
    <span class="k">if</span> <span class="n">num_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="n">edge_distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        
        <span class="n">avg_edge_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>
        <span class="n">min_edge_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>
        <span class="n">max_edge_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>
        
        <span class="n">avg_edge_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edge_distances</span><span class="p">)</span>
        <span class="n">min_edge_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">edge_distances</span><span class="p">)</span>
        <span class="n">max_edge_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">edge_distances</span><span class="p">)</span>
        
        <span class="c1"># Calculate edge overlap statistics if available</span>
        <span class="k">if</span> <span class="n">use_polygons</span> <span class="ow">and</span> <span class="n">edge_overlap_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edge_overlaps</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;overlap&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">edge_overlaps</span><span class="p">:</span>
                <span class="n">avg_edge_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edge_overlaps</span><span class="p">)</span>
                <span class="n">min_edge_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">edge_overlaps</span><span class="p">)</span>
                <span class="n">max_edge_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">edge_overlaps</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_edge_overlap</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">min_edge_overlap</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">max_edge_overlap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">avg_edge_overlap</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">min_edge_overlap</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">max_edge_overlap</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">avg_edge_weight</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_edge_weight</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_edge_weight</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">avg_edge_distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_edge_distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_edge_distance</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">avg_edge_overlap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_edge_overlap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_edge_overlap</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Calculate cell type interaction statistics if cell type information is available</span>
    <span class="n">cell_type_interactions</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;cell_type&#39;</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># Count interactions between each pair of cell types</span>
        <span class="n">interaction_counts</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">u_type</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">v_type</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">u_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Create a sorted tuple to ensure symmetry in undirected graphs</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
                    <span class="n">type_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">u_type</span><span class="p">,</span> <span class="n">v_type</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">type_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_type</span><span class="p">,</span> <span class="n">v_type</span><span class="p">)</span>
                
                <span class="n">interaction_counts</span><span class="p">[</span><span class="n">type_pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">interaction_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">type_pair</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># Convert to DataFrame</span>
        <span class="n">interactions</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">),</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">interaction_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;cell_type1&#39;</span><span class="p">:</span> <span class="n">type1</span><span class="p">,</span>
                <span class="s1">&#39;cell_type2&#39;</span><span class="p">:</span> <span class="n">type2</span><span class="p">,</span>
                <span class="s1">&#39;interaction_count&#39;</span><span class="p">:</span> <span class="n">count</span>
            <span class="p">})</span>
        
        <span class="n">cell_type_interactions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">interactions</span><span class="p">)</span>
        
        <span class="c1"># Calculate expected interactions under random mixing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
            <span class="c1"># Count cells of each type</span>
            <span class="n">type_counts</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="n">total_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
            
            <span class="c1"># Calculate expected number of interactions</span>
            <span class="n">expected_interactions</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">type1</span><span class="p">,</span> <span class="n">count1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">type_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">type2</span><span class="p">,</span> <span class="n">count2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">type_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Only include each type pair once</span>
                        <span class="c1"># Expected number of edges between types</span>
                        <span class="k">if</span> <span class="n">type1</span> <span class="o">==</span> <span class="n">type2</span><span class="p">:</span>
                            <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="n">count1</span> <span class="o">*</span> <span class="p">(</span><span class="n">count1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_cells</span> <span class="o">*</span> <span class="p">(</span><span class="n">total_cells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">num_edges</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="n">count1</span> <span class="o">*</span> <span class="n">count2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_cells</span> <span class="o">*</span> <span class="p">(</span><span class="n">total_cells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">num_edges</span> <span class="o">*</span> <span class="mi">2</span>
                        
                        <span class="c1"># Find actual count</span>
                        <span class="n">type_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">]))</span>
                        <span class="n">actual</span> <span class="o">=</span> <span class="n">interaction_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">type_pair</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        
                        <span class="n">expected_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;cell_type1&#39;</span><span class="p">:</span> <span class="n">type1</span><span class="p">,</span>
                            <span class="s1">&#39;cell_type2&#39;</span><span class="p">:</span> <span class="n">type2</span><span class="p">,</span>
                            <span class="s1">&#39;expected_count&#39;</span><span class="p">:</span> <span class="n">expected</span><span class="p">,</span>
                            <span class="s1">&#39;actual_count&#39;</span><span class="p">:</span> <span class="n">actual</span><span class="p">,</span>
                            <span class="s1">&#39;interaction_ratio&#39;</span><span class="p">:</span> <span class="n">actual</span> <span class="o">/</span> <span class="n">expected</span> <span class="k">if</span> <span class="n">expected</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="p">})</span>
            
            <span class="c1"># Convert to DataFrame</span>
            <span class="n">cell_type_interactions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">expected_interactions</span><span class="p">)</span>
    
    <span class="c1"># Create polygon statistics if using polygons</span>
    <span class="n">polygon_stats</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
        <span class="n">polygon_data</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_polygons</span><span class="p">:</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">cell_polygons</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
                
                <span class="c1"># Calculate basic polygon metrics</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
                <span class="n">perimeter</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">length</span>
                
                <span class="c1"># Calculate shape features</span>
                <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Circularity (= 4 * area / perimeter^2)</span>
                    <span class="n">circularity</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="n">perimeter</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    
                    <span class="c1"># Solidity (= area / convex hull area)</span>
                    <span class="n">convex_hull</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">convex_hull</span>
                    <span class="n">solidity</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">convex_hull</span><span class="o">.</span><span class="n">area</span> <span class="k">if</span> <span class="n">convex_hull</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                    
                    <span class="c1"># Eccentricity (based on minimum bounding rectangle)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">min_rect</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">minimum_rotated_rectangle</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">min_rect</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">eccentricity</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">eccentricity</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">circularity</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">solidity</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">eccentricity</span> <span class="o">=</span> <span class="mi">0</span>
                
                <span class="c1"># Get centroid</span>
                <span class="n">centroid</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">centroid</span>
                
                <span class="c1"># Store polygon data</span>
                <span class="n">polygon_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                    <span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="n">area</span><span class="p">,</span>
                    <span class="s1">&#39;perimeter&#39;</span><span class="p">:</span> <span class="n">perimeter</span><span class="p">,</span>
                    <span class="s1">&#39;circularity&#39;</span><span class="p">:</span> <span class="n">circularity</span><span class="p">,</span>
                    <span class="s1">&#39;solidity&#39;</span><span class="p">:</span> <span class="n">solidity</span><span class="p">,</span>
                    <span class="s1">&#39;eccentricity&#39;</span><span class="p">:</span> <span class="n">eccentricity</span><span class="p">,</span>
                    <span class="s1">&#39;centroid_x&#39;</span><span class="p">:</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                    <span class="s1">&#39;centroid_y&#39;</span><span class="p">:</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span>
                <span class="p">})</span>
        
        <span class="c1"># Create DataFrame</span>
        <span class="k">if</span> <span class="n">polygon_data</span><span class="p">:</span>
            <span class="n">polygon_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">polygon_data</span><span class="p">)</span>
            <span class="n">polygon_stats</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Add cell type if available</span>
            <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">polygon_stats</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
                                             <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">polygon_stats</span><span class="o">.</span><span class="n">index</span> 
                                             <span class="k">if</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
    
    <span class="c1"># Create result dictionary</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;network_stats&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;num_nodes&#39;</span><span class="p">:</span> <span class="n">num_nodes</span><span class="p">,</span>
            <span class="s1">&#39;num_edges&#39;</span><span class="p">:</span> <span class="n">num_edges</span><span class="p">,</span>
            <span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="n">density</span><span class="p">,</span>
            <span class="s1">&#39;num_components&#39;</span><span class="p">:</span> <span class="n">num_components</span><span class="p">,</span>
            <span class="s1">&#39;largest_component_size&#39;</span><span class="p">:</span> <span class="n">largest_component_size</span><span class="p">,</span>
            <span class="s1">&#39;avg_path_length&#39;</span><span class="p">:</span> <span class="n">avg_path_length</span><span class="p">,</span>
            <span class="s1">&#39;diameter&#39;</span><span class="p">:</span> <span class="n">diameter</span><span class="p">,</span>
            <span class="s1">&#39;clustering_coefficient&#39;</span><span class="p">:</span> <span class="n">clustering_coefficient</span><span class="p">,</span>
            <span class="s1">&#39;avg_degree&#39;</span><span class="p">:</span> <span class="n">avg_degree</span><span class="p">,</span>
            <span class="s1">&#39;min_degree&#39;</span><span class="p">:</span> <span class="n">min_degree</span><span class="p">,</span>
            <span class="s1">&#39;max_degree&#39;</span><span class="p">:</span> <span class="n">max_degree</span><span class="p">,</span>
            <span class="s1">&#39;degree_std&#39;</span><span class="p">:</span> <span class="n">degree_std</span><span class="p">,</span>
            <span class="s1">&#39;avg_edge_weight&#39;</span><span class="p">:</span> <span class="n">avg_edge_weight</span><span class="p">,</span>
            <span class="s1">&#39;min_edge_weight&#39;</span><span class="p">:</span> <span class="n">min_edge_weight</span><span class="p">,</span>
            <span class="s1">&#39;max_edge_weight&#39;</span><span class="p">:</span> <span class="n">max_edge_weight</span><span class="p">,</span>
            <span class="s1">&#39;avg_edge_distance&#39;</span><span class="p">:</span> <span class="n">avg_edge_distance</span><span class="p">,</span>
            <span class="s1">&#39;min_edge_distance&#39;</span><span class="p">:</span> <span class="n">min_edge_distance</span><span class="p">,</span>
            <span class="s1">&#39;max_edge_distance&#39;</span><span class="p">:</span> <span class="n">max_edge_distance</span><span class="p">,</span>
            <span class="s1">&#39;avg_edge_overlap&#39;</span><span class="p">:</span> <span class="n">avg_edge_overlap</span><span class="p">,</span>
            <span class="s1">&#39;min_edge_overlap&#39;</span><span class="p">:</span> <span class="n">min_edge_overlap</span><span class="p">,</span>
            <span class="s1">&#39;max_edge_overlap&#39;</span><span class="p">:</span> <span class="n">max_edge_overlap</span><span class="p">,</span>
            <span class="s1">&#39;directed&#39;</span><span class="p">:</span> <span class="n">directed</span><span class="p">,</span>
            <span class="s1">&#39;use_polygons&#39;</span><span class="p">:</span> <span class="n">use_polygons</span><span class="p">,</span>
            <span class="s1">&#39;connection_method&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;polygon_distance&#39;</span> <span class="k">if</span> <span class="n">use_polygons</span> <span class="k">else</span> 
                                <span class="p">(</span><span class="s1">&#39;distance_threshold&#39;</span> <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;k_nearest&#39;</span><span class="p">)),</span>
            <span class="s1">&#39;threshold_value&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">distance_threshold</span> <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> 
                             <span class="p">(</span><span class="n">k_nearest</span> <span class="k">if</span> <span class="n">k_nearest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edge_overlap_threshold</span><span class="p">))</span>
        <span class="p">},</span>
        <span class="s1">&#39;node_metrics&#39;</span><span class="p">:</span> <span class="n">node_metrics</span><span class="p">,</span>
        <span class="s1">&#39;communities&#39;</span><span class="p">:</span> <span class="n">communities</span><span class="p">,</span>
        <span class="s1">&#39;community_metrics&#39;</span><span class="p">:</span> <span class="n">community_metrics</span><span class="p">,</span>
        <span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="n">edge_df</span><span class="p">,</span>
        <span class="s1">&#39;cell_type_interactions&#39;</span><span class="p">:</span> <span class="n">cell_type_interactions</span><span class="p">,</span>
        <span class="s1">&#39;polygon_stats&#39;</span><span class="p">:</span> <span class="n">polygon_stats</span><span class="p">,</span>
        <span class="s1">&#39;graph&#39;</span><span class="p">:</span> <span class="n">G</span>  <span class="c1"># Include the actual graph for further analysis</span>
    <span class="p">}</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="c1"># Define plot configuration based on what&#39;s available</span>
        <span class="k">if</span> <span class="n">use_polygons</span><span class="p">:</span>
            <span class="c1"># Network plot with polygons</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;polygon_network&#39;</span><span class="p">,</span>
                <span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;polygon&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
                           <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;polygon&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]},</span>
                <span class="s1">&#39;node_positions&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> 
                                <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()},</span>
                <span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell Interaction Network with Polygons&#39;</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;community&#39;</span> <span class="k">if</span> <span class="n">communities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> 
                           <span class="p">(</span><span class="s1">&#39;cell_type&#39;</span> <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                <span class="s1">&#39;node_colors&#39;</span><span class="p">:</span> <span class="n">communities</span><span class="p">[</span><span class="s1">&#39;community&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">communities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> 
                             <span class="p">({</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
                              <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span> <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                <span class="s1">&#39;edge_width_by&#39;</span><span class="p">:</span> <span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                <span class="s1">&#39;show_edges&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">community_detection</span> <span class="ow">and</span> <span class="n">communities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Community detection plot</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;network&#39;</span><span class="p">,</span>
                <span class="s1">&#39;node_positions&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> 
                                <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()},</span>
                <span class="s1">&#39;node_colors&#39;</span><span class="p">:</span> <span class="n">communities</span><span class="p">[</span><span class="s1">&#39;community&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell Interaction Network with Communities&#39;</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;community&#39;</span><span class="p">,</span>
                <span class="s1">&#39;node_size_by&#39;</span><span class="p">:</span> <span class="s1">&#39;degree_centrality&#39;</span> <span class="k">if</span> <span class="n">node_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;edge_width_by&#39;</span><span class="p">:</span> <span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                <span class="s1">&#39;show_labels&#39;</span><span class="p">:</span> <span class="kc">False</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Cell type colored network</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;network&#39;</span><span class="p">,</span>
                <span class="s1">&#39;node_positions&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> 
                                <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()},</span>
                <span class="s1">&#39;node_colors&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
                              <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()},</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell Interaction Network by Cell Type&#39;</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span>
                <span class="s1">&#39;node_size_by&#39;</span><span class="p">:</span> <span class="s1">&#39;degree_centrality&#39;</span> <span class="k">if</span> <span class="n">node_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;edge_width_by&#39;</span><span class="p">:</span> <span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                <span class="s1">&#39;show_labels&#39;</span><span class="p">:</span> <span class="kc">False</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Basic network plot</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;network&#39;</span><span class="p">,</span>
                <span class="s1">&#39;node_positions&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cell_id</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> 
                                <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()},</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Cell Interaction Network&#39;</span><span class="p">,</span>
                <span class="s1">&#39;node_size_by&#39;</span><span class="p">:</span> <span class="s1">&#39;degree_centrality&#39;</span> <span class="k">if</span> <span class="n">node_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;edge_width_by&#39;</span><span class="p">:</span> <span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                <span class="s1">&#39;show_labels&#39;</span><span class="p">:</span> <span class="kc">False</span>
            <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">plot_config</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="calculate_gene_spatial_autocorrelation">
<a class="viewcode-back" href="../../../api/tl.html#SpatioloJI.tl.Spatial_function.calculate_gene_spatial_autocorrelation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_gene_spatial_autocorrelation</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="p">,</span> <span class="n">genes</span><span class="p">,</span> <span class="n">max_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                         <span class="n">distance_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fov_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_global_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">method</span><span class="o">=</span><span class="s1">&#39;moran&#39;</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate spatial autocorrelation of gene expression across the tissue.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spatioloji_obj: A Spatioloji object</span>
<span class="sd">        genes: List of gene names or a single gene name to analyze</span>
<span class="sd">        max_distance: Maximum distance (in pixels) to consider for autocorrelation (None for auto-determination)</span>
<span class="sd">        distance_bins: Number of distance bins for correlogram analysis</span>
<span class="sd">        fov_id: Optional FOV ID to restrict analysis to a specific FOV</span>
<span class="sd">        use_global_coords: Whether to use global coordinates (True) or local coordinates (False)</span>
<span class="sd">        cell_type: Optional cell type to filter cells (None for all cells)</span>
<span class="sd">        cell_type_column: Column name in adata.obs containing cell type information (required if cell_type is provided)</span>
<span class="sd">        method: Method for spatial autocorrelation (&#39;moran&#39;, &#39;geary&#39;, or &#39;correlogram&#39;)</span>
<span class="sd">        permutations: Number of Monte Carlo simulations for significance testing (0 for none)</span>
<span class="sd">        n_jobs: Number of parallel jobs for permutations (-1 for all processors)</span>
<span class="sd">        plot_result: Whether to return a plot configuration (True) or not (False)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with spatial autocorrelation statistics for each gene</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
    
    <span class="c1"># Handle single gene input</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">genes</span><span class="p">]</span>
    
    <span class="c1"># Determine which coordinates to use</span>
    <span class="k">if</span> <span class="n">use_global_coords</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_global_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_global_px&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_col</span> <span class="o">=</span> <span class="s1">&#39;CenterX_local_px&#39;</span>
        <span class="n">y_col</span> <span class="o">=</span> <span class="s1">&#39;CenterY_local_px&#39;</span>
    
    <span class="c1"># Get the cell metadata to work with</span>
    <span class="k">if</span> <span class="n">fov_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">get_cells_in_fov</span><span class="p">(</span><span class="n">fov_id</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">cell_meta</span>
    
    <span class="c1"># Check if we have the necessary columns</span>
    <span class="k">if</span> <span class="n">x_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">y_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="n">x_col</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y_col</span><span class="si">}</span><span class="s2"> not found in cell metadata&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter by cell type if specified</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_type_column must be provided when cell_type is specified&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cell type column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
            
        <span class="c1"># Create a dictionary mapping cell IDs to cell types</span>
        <span class="n">cell_to_type</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="c1"># Add cell type information to the cells DataFrame</span>
        <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cell_to_type</span><span class="p">)</span>
        
        <span class="c1"># Filter to only include cells of the specified type</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cells of type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39; found&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract coordinates and cell IDs</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[[</span><span class="n">x_col</span><span class="p">,</span> <span class="n">y_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Check if we have enough cells</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough cells for spatial autocorrelation analysis (need at least 5)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Get gene expression values from AnnData object</span>
    <span class="c1"># First, validate genes exist in the data</span>
    <span class="n">var_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
    <span class="n">missing_genes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">genes</span><span class="p">)</span> <span class="o">-</span> <span class="n">var_names</span>
    
    <span class="k">if</span> <span class="n">missing_genes</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following genes were not found in the data: </span><span class="si">{</span><span class="n">missing_genes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1"># Filter to only include genes in the data</span>
    <span class="n">valid_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">gene</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">genes</span> <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_genes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;None of the specified genes were found in the data&quot;</span><span class="p">)</span>
    
    <span class="c1"># Extract gene expression values</span>
    <span class="n">gene_expression</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">valid_genes</span><span class="p">:</span>
        <span class="c1"># Get expression values for all cells</span>
        <span class="n">gene_idx</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
        <span class="n">expr_values</span> <span class="o">=</span> <span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">gene_idx</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1"># Create mapping from cell ID to expression value</span>
        <span class="n">expr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">expr_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spatioloji_obj</span><span class="o">.</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">)}</span>
        
        <span class="c1"># Get expression for cells in our filtered set</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">expr_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">])</span>
        
        <span class="c1"># Store gene expression values</span>
        <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>
    
    <span class="c1"># Calculate pairwise distances</span>
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    <span class="c1"># Determine max distance if not specified</span>
    <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use half the maximum distance for autocorrelation</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="c1"># Create distance bins for correlogram</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;correlogram&#39;</span><span class="p">:</span>
        <span class="n">distance_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">distance_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">distance_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">distance_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Calculate spatial weights matrix</span>
    <span class="c1"># For Moran&#39;s I and Geary&#39;s C, we use a binary weights matrix with a distance threshold</span>
    <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
    <span class="n">weights_matrix</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">weights_matrix</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Exclude self-connections</span>
    
    <span class="c1"># Row-normalize the weights matrix</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Avoid division by zero</span>
    <span class="n">weights_matrix</span> <span class="o">=</span> <span class="n">weights_matrix</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    
    <span class="c1"># Function to calculate Moran&#39;s I for a single gene</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_morans_i</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">):</span>
        <span class="c1"># Standardize expression values</span>
        <span class="n">expr_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        
        <span class="c1"># Calculate spatial lag (weighted average of neighboring values)</span>
        <span class="n">spatial_lag</span> <span class="o">=</span> <span class="n">weights_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expr_std</span><span class="p">)</span>
        
        <span class="c1"># Calculate Moran&#39;s I</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr_std</span> <span class="o">*</span> <span class="n">spatial_lag</span><span class="p">)</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">gene</span><span class="p">,</span>
                <span class="s1">&#39;morans_i&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="s1">&#39;No variation&#39;</span>
            <span class="p">}</span>
        
        <span class="n">morans_i</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
        
        <span class="c1"># Calculate expected value of Moran&#39;s I under the null hypothesis</span>
        <span class="n">expected_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Calculate variance of Moran&#39;s I under the null hypothesis</span>
        <span class="c1"># This is a simplified formula; the exact formula is more complex</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">weights_matrix</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">var_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">s2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Calculate z-score</span>
        <span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">morans_i</span> <span class="o">-</span> <span class="n">expected_i</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_i</span><span class="p">)</span>
        
        <span class="c1"># Calculate p-value</span>
        <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z_score</span><span class="p">)))</span>  <span class="c1"># Two-tailed test</span>
        
        <span class="c1"># Determine if spatial pattern is clustered, random, or dispersed</span>
        <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">morans_i</span> <span class="o">&gt;</span> <span class="n">expected_i</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Clustered&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Dispersed&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">gene</span><span class="p">,</span>
            <span class="s1">&#39;morans_i&#39;</span><span class="p">:</span> <span class="n">morans_i</span><span class="p">,</span>
            <span class="s1">&#39;expected_i&#39;</span><span class="p">:</span> <span class="n">expected_i</span><span class="p">,</span>
            <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="n">z_score</span><span class="p">,</span>
            <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
            <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="n">pattern</span>
        <span class="p">}</span>
    
    <span class="c1"># Function to calculate Geary&#39;s C for a single gene</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_gearys_c</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">):</span>
        <span class="c1"># Calculate mean expression</span>
        <span class="n">expr_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        
        <span class="c1"># Calculate Geary&#39;s C</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        
        <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">max_distance</span><span class="p">:</span>
                    <span class="n">numerator</span> <span class="o">+=</span> <span class="n">weights_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">expr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">expr</span> <span class="o">-</span> <span class="n">expr_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">gene</span><span class="p">,</span>
                <span class="s1">&#39;gearys_c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="s1">&#39;No variation&#39;</span>
            <span class="p">}</span>
        
        <span class="c1"># Scale by number of observations and sum of weights</span>
        <span class="n">sum_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_matrix</span><span class="p">)</span>
        <span class="n">gearys_c</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numerator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sum_weights</span> <span class="o">*</span> <span class="n">denominator</span><span class="p">)</span>
        
        <span class="c1"># Calculate expected value of Geary&#39;s C under the null hypothesis</span>
        <span class="n">expected_c</span> <span class="o">=</span> <span class="mf">1.0</span>
        
        <span class="c1"># Calculate variance of Geary&#39;s C under the null hypothesis</span>
        <span class="c1"># This is a simplified formula; the exact formula is more complex</span>
        <span class="n">var_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sum_weights</span><span class="p">)</span>
        
        <span class="c1"># Calculate z-score</span>
        <span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">gearys_c</span> <span class="o">-</span> <span class="n">expected_c</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_c</span><span class="p">)</span>
        
        <span class="c1"># Calculate p-value</span>
        <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z_score</span><span class="p">)))</span>  <span class="c1"># Two-tailed test</span>
        
        <span class="c1"># Determine if spatial pattern is clustered, random, or dispersed</span>
        <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gearys_c</span> <span class="o">&lt;</span> <span class="n">expected_c</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Clustered&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Dispersed&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">gene</span><span class="p">,</span>
            <span class="s1">&#39;gearys_c&#39;</span><span class="p">:</span> <span class="n">gearys_c</span><span class="p">,</span>
            <span class="s1">&#39;expected_c&#39;</span><span class="p">:</span> <span class="n">expected_c</span><span class="p">,</span>
            <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="n">z_score</span><span class="p">,</span>
            <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
            <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="n">pattern</span>
        <span class="p">}</span>
    
    <span class="c1"># Function to calculate correlogram for a single gene</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_correlogram</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">distance_edges</span><span class="p">):</span>
        <span class="c1"># Calculate Moran&#39;s I at different distances</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">expr_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        
        <span class="c1"># Initialize arrays for correlogram</span>
        <span class="n">moran_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">n_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Calculate Moran&#39;s I for each distance bin</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">d_min</span> <span class="o">=</span> <span class="n">distance_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">d_max</span> <span class="o">=</span> <span class="n">distance_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># Create weights matrix for this distance bin</span>
            <span class="n">bin_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
            <span class="n">bin_weights</span><span class="p">[(</span><span class="n">dist_matrix</span> <span class="o">&gt;</span> <span class="n">d_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist_matrix</span> <span class="o">&lt;=</span> <span class="n">d_max</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">bin_weights</span><span class="p">[</span><span class="n">dist_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Exclude self-connections</span>
            
            <span class="c1"># Count pairs in this bin</span>
            <span class="n">n_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_weights</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">n_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Row-normalize the weights matrix</span>
                <span class="n">row_sums</span> <span class="o">=</span> <span class="n">bin_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Avoid division by zero</span>
                <span class="n">bin_weights</span> <span class="o">=</span> <span class="n">bin_weights</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                
                <span class="c1"># Calculate spatial lag</span>
                <span class="n">spatial_lag</span> <span class="o">=</span> <span class="n">bin_weights</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expr_std</span><span class="p">)</span>
                
                <span class="c1"># Calculate Moran&#39;s I for this distance bin</span>
                <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr_std</span> <span class="o">*</span> <span class="n">spatial_lag</span><span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">denominator</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">moran_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">moran_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">moran_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">gene</span><span class="p">,</span>
            <span class="s1">&#39;distance_centers&#39;</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">distance_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="s1">&#39;moran_values&#39;</span><span class="p">:</span> <span class="n">moran_values</span><span class="p">,</span>
            <span class="s1">&#39;n_pairs&#39;</span><span class="p">:</span> <span class="n">n_pairs</span>
        <span class="p">}</span>
    
    <span class="c1"># Calculate autocorrelation for all genes</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;moran&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate Moran&#39;s I for each gene</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">valid_genes</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_morans_i</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene</span><span class="p">],</span> <span class="n">weights_matrix</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="c1"># Convert to DataFrame</span>
        <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;geary&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate Geary&#39;s C for each gene</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">valid_genes</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_gearys_c</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene</span><span class="p">],</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="c1"># Convert to DataFrame</span>
        <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;correlogram&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate correlogram for each gene</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">valid_genes</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_correlogram</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene</span><span class="p">],</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">distance_edges</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="c1"># Convert to list of DataFrames, one for each gene</span>
        <span class="n">correlograms</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span>
            
            <span class="c1"># Create DataFrame for this gene</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">gene</span><span class="p">,</span>
                <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;distance_centers&#39;</span><span class="p">],</span>
                <span class="s1">&#39;morans_i&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;moran_values&#39;</span><span class="p">],</span>
                <span class="s1">&#39;n_pairs&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;n_pairs&#39;</span><span class="p">]</span>
            <span class="p">})</span>
            
            <span class="n">correlograms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        
        <span class="c1"># Combine all DataFrames</span>
        <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">correlograms</span><span class="p">)</span>
    
    <span class="c1"># Calculate Monte Carlo significance if requested</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;moran&#39;</span><span class="p">,</span> <span class="s1">&#39;geary&#39;</span><span class="p">]:</span>
        <span class="c1"># Determine number of cores to use</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        
        <span class="c1"># Function to calculate autocorrelation for a random permutation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_random_autocorrelation</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
            <span class="c1"># Randomly permute the expression values</span>
            <span class="n">random_expr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;moran&#39;</span><span class="p">:</span>
                <span class="c1"># Calculate Moran&#39;s I for random permutation</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_morans_i</span><span class="p">(</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="n">random_expr</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;morans_i&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate Geary&#39;s C for random permutation</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_gearys_c</span><span class="p">(</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="n">random_expr</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;gearys_c&#39;</span><span class="p">]</span>
        
        <span class="c1"># Calculate autocorrelation for random permutations</span>
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">valid_genes</span><span class="p">:</span>
            <span class="c1"># Get expression values for this gene</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span>
            
            <span class="c1"># Run permutations in parallel</span>
            <span class="n">random_values</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">calculate_random_autocorrelation</span><span class="p">)(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">weights_matrix</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">method</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Monte Carlo simulations for </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            
            <span class="c1"># Convert to numpy array</span>
            <span class="n">random_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">random_values</span><span class="p">)</span>
            
            <span class="c1"># Calculate empirical p-value</span>
            <span class="n">gene_idx</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">[</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;moran&#39;</span><span class="p">:</span>
                <span class="c1"># For Moran&#39;s I, count how many random values are &gt;= observed</span>
                <span class="n">observed_i</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;morans_i&#39;</span><span class="p">]</span>
                <span class="n">p_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">random_values</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">observed_i</span><span class="p">))</span>
                
                <span class="c1"># Update p-value in result_df</span>
                <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;p_value_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_value</span>
                
                <span class="c1"># Update pattern based on Monte Carlo p-value</span>
                <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">observed_i</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">random_values</span><span class="p">):</span>
                        <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;pattern_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Clustered&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;pattern_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Dispersed&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;pattern_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For Geary&#39;s C, count how many random values are &lt;= observed</span>
                <span class="n">observed_c</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;gearys_c&#39;</span><span class="p">]</span>
                <span class="n">p_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">random_values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">observed_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Update p-value in result_df</span>
                <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;p_value_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_value</span>
                
                <span class="c1"># Update pattern based on Monte Carlo p-value</span>
                <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">observed_c</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;pattern_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Clustered&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;pattern_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Dispersed&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_idx</span><span class="p">,</span> <span class="s1">&#39;pattern_mc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
    
    <span class="c1"># Generate plot configuration if requested</span>
    <span class="n">plot_config</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;correlogram&#39;</span><span class="p">:</span>
            <span class="c1"># Plot correlogram</span>
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;morans_i&#39;</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;gene&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Spatial Correlogram of Gene Expression&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Distance (pixels)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="s2">&quot;Moran&#39;s I&quot;</span><span class="p">,</span>
                <span class="s1">&#39;reference_line&#39;</span><span class="p">:</span> <span class="mi">0</span>  <span class="c1"># Add horizontal line at 0</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Bar plot of autocorrelation values</span>
            <span class="n">stat_column</span> <span class="o">=</span> <span class="s1">&#39;morans_i&#39;</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;moran&#39;</span> <span class="k">else</span> <span class="s1">&#39;gearys_c&#39;</span>
            <span class="n">reference_line</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;moran&#39;</span> <span class="k">else</span> <span class="mi">1</span>
            
            <span class="n">plot_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;gene&#39;</span><span class="p">,</span>
                <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">stat_column</span><span class="p">,</span>
                <span class="s1">&#39;color_by&#39;</span><span class="p">:</span> <span class="s1">&#39;pattern&#39;</span><span class="p">,</span>
                <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;Spatial Autocorrelation of Gene Expression (</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;reference_line&#39;</span><span class="p">:</span> <span class="n">reference_line</span><span class="p">,</span>
                <span class="s1">&#39;ylim&#39;</span><span class="p">:</span> <span class="kc">None</span>  <span class="c1"># Automatically determine y-axis limits</span>
            <span class="p">}</span>
    
    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;result&#39;</span><span class="p">:</span> <span class="n">result_df</span><span class="p">,</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
        <span class="s1">&#39;max_distance&#39;</span><span class="p">:</span> <span class="n">max_distance</span><span class="p">,</span>
        <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="n">cell_type</span><span class="p">,</span>
        <span class="s1">&#39;plot_config&#39;</span><span class="p">:</span> <span class="n">plot_config</span>
    <span class="p">}</span></div>








</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, SpatioloJI Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>